{
  "address": "0xBD62Aa492d86a14c7d5F5CC83b045f4276BB6F8f",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_settings_address",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_vault_address",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "provider",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "deal_index",
          "type": "uint256"
        }
      ],
      "name": "AppealCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "AppealStarted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "DealInvalidated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "RoundSlashed",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "active_appeals",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "active_referees",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "appeals",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "deal_index",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "active",
          "type": "bool"
        },
        {
          "internalType": "uint128",
          "name": "slashes",
          "type": "uint128"
        },
        {
          "internalType": "uint256",
          "name": "request_timestamp",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "origin_timestamp",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "deal_index",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "appeal_address",
          "type": "address"
        }
      ],
      "name": "canAddressAppeal",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "deal_index",
          "type": "uint256"
        }
      ],
      "name": "createAppeal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_endpoint",
          "type": "string"
        }
      ],
      "name": "emulateReferee",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "appeal_index",
          "type": "uint256"
        }
      ],
      "name": "getElectedLeader",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "appeal_index",
          "type": "uint256"
        }
      ],
      "name": "getPrefix",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "appeal_index",
          "type": "uint256"
        }
      ],
      "name": "getRound",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "deal_index",
          "type": "uint256"
        }
      ],
      "name": "hasNoActiveAppeals",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "deal_index",
          "type": "uint256"
        }
      ],
      "name": "hasNoPendingAppeals",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "check",
          "type": "address"
        }
      ],
      "name": "isReferee",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "pending_appeals",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "deal_index",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "_referees",
          "type": "address[]"
        },
        {
          "internalType": "bytes[]",
          "name": "_signatures",
          "type": "bytes[]"
        }
      ],
      "name": "processAppeal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "refereeConsensusThreshold",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "referees",
      "outputs": [
        {
          "internalType": "bool",
          "name": "active",
          "type": "bool"
        },
        {
          "internalType": "string",
          "name": "endpoint",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "deal_index",
          "type": "uint256"
        }
      ],
      "name": "returnAppealFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_deals_address",
          "type": "address"
        }
      ],
      "name": "setDealsAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_referee",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "_state",
          "type": "bool"
        },
        {
          "internalType": "string",
          "name": "_endpoint",
          "type": "string"
        }
      ],
      "name": "setRefereeStatus",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "appeal_index",
          "type": "uint256"
        }
      ],
      "name": "startAppeal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "tot_appeals",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalAppeals",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_signature",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "deal_index",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "referee",
          "type": "address"
        }
      ],
      "name": "verifyRefereeSignature",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x735c1f7dba8223a2f78487d16fa7b88e5362d5c0973b0fcc69afe3fcf1a4e900",
  "receipt": {
    "to": null,
    "from": "0x81A91158497A1cD700De7f6D83ee565788A9C273",
    "contractAddress": "0xBD62Aa492d86a14c7d5F5CC83b045f4276BB6F8f",
    "transactionIndex": 0,
    "gasUsed": "111379284",
    "logsBloom": "0x6cc0818c8a00208029b640c074d01cd28e4021044703244007a0d00241261cc381063472896422000a1038c405959e010ae31305080080214a55280210a40286433299004103f000000000dc0060128c084b4200610c960191721200c3411050480504044a3624490073019404297815282009a0fa0046ca007210399104ba70100a24224517980044509014011451c24c08caa0a010488b06115908c00f00c35e00c840252242104220130220404c00a47001200290803602d090806708f20a29a28c2268008016f014189004843120aa0289101c4a620101b9c121e100e0010218042049803912005114092209088067c0088a03800940a1a40808428d6040",
    "blockHash": "0xc3f56ee6dd416afbc27f81254700ae9024abe5dcf0cf76b5458418ce7417ff42",
    "transactionHash": "0x735c1f7dba8223a2f78487d16fa7b88e5362d5c0973b0fcc69afe3fcf1a4e900",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 963490,
        "transactionHash": "0x735c1f7dba8223a2f78487d16fa7b88e5362d5c0973b0fcc69afe3fcf1a4e900",
        "address": "0xBD62Aa492d86a14c7d5F5CC83b045f4276BB6F8f",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x00000000000000000000000081a91158497a1cd700de7f6d83ee565788a9c273"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0xc3f56ee6dd416afbc27f81254700ae9024abe5dcf0cf76b5458418ce7417ff42"
      }
    ],
    "blockNumber": 963490,
    "cumulativeGasUsed": "0",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x591239742B2f363e10880f74B84fDa0bd19e5F2F",
    "0x1454e343dB91a6Aad1Df60F5845049AdDf439C5E"
  ],
  "numDeployments": 12,
  "solcInputHash": "cbe19a9e5fa7ec80f4c3557b29d4e889",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_settings_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vault_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deal_index\",\"type\":\"uint256\"}],\"name\":\"AppealCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"AppealStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"DealInvalidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"RoundSlashed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"active_appeals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"active_referees\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"appeals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"deal_index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"slashes\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"request_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"origin_timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deal_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"appeal_address\",\"type\":\"address\"}],\"name\":\"canAddressAppeal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deal_index\",\"type\":\"uint256\"}],\"name\":\"createAppeal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_endpoint\",\"type\":\"string\"}],\"name\":\"emulateReferee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"appeal_index\",\"type\":\"uint256\"}],\"name\":\"getElectedLeader\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"appeal_index\",\"type\":\"uint256\"}],\"name\":\"getPrefix\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"appeal_index\",\"type\":\"uint256\"}],\"name\":\"getRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deal_index\",\"type\":\"uint256\"}],\"name\":\"hasNoActiveAppeals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deal_index\",\"type\":\"uint256\"}],\"name\":\"hasNoPendingAppeals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"check\",\"type\":\"address\"}],\"name\":\"isReferee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pending_appeals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deal_index\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_referees\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_signatures\",\"type\":\"bytes[]\"}],\"name\":\"processAppeal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refereeConsensusThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"endpoint\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deal_index\",\"type\":\"uint256\"}],\"name\":\"returnAppealFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_deals_address\",\"type\":\"address\"}],\"name\":\"setDealsAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referee\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"_endpoint\",\"type\":\"string\"}],\"name\":\"setRefereeStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"appeal_index\",\"type\":\"uint256\"}],\"name\":\"startAppeal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tot_appeals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAppeals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"deal_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"}],\"name\":\"verifyRefereeSignature\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"title\":\"Appeals\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/retrieve/appeals/Appeals.sol\":\"Appeals\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":true,\"cse\":true,\"deduplicate\":true,\"inliner\":true,\"jumpdestRemover\":true,\"orderLiterals\":true,\"peephole\":true,\"yul\":false},\"runs\":1000},\"remappings\":[]},\"sources\":{\"@ensdomains/buffer/contracts/Buffer.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-2-Clause\\npragma solidity ^0.8.4;\\n\\n/**\\n* @dev A library for working with mutable byte buffers in Solidity.\\n*\\n* Byte buffers are mutable and expandable, and provide a variety of primitives\\n* for appending to them. At any time you can fetch a bytes object containing the\\n* current contents of the buffer. The bytes object should not be stored between\\n* operations, as it may change due to resizing of the buffer.\\n*/\\nlibrary Buffer {\\n    /**\\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n    *      a capacity. The capacity may be longer than the current value, in\\n    *      which case it can be extended without the need to allocate more memory.\\n    */\\n    struct buffer {\\n        bytes buf;\\n        uint capacity;\\n    }\\n\\n    /**\\n    * @dev Initializes a buffer with an initial capacity.\\n    * @param buf The buffer to initialize.\\n    * @param capacity The number of bytes of space to allocate the buffer.\\n    * @return The buffer, for chaining.\\n    */\\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\\n        if (capacity % 32 != 0) {\\n            capacity += 32 - (capacity % 32);\\n        }\\n        // Allocate space for the buffer data\\n        buf.capacity = capacity;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(buf, ptr)\\n            mstore(ptr, 0)\\n            let fpm := add(32, add(ptr, capacity))\\n            if lt(fpm, ptr) {\\n                revert(0, 0)\\n            }\\n            mstore(0x40, fpm)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Initializes a new buffer from an existing bytes object.\\n    *      Changes to the buffer may mutate the original value.\\n    * @param b The bytes object to initialize the buffer with.\\n    * @return A new buffer.\\n    */\\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\\n        buffer memory buf;\\n        buf.buf = b;\\n        buf.capacity = b.length;\\n        return buf;\\n    }\\n\\n    function resize(buffer memory buf, uint capacity) private pure {\\n        bytes memory oldbuf = buf.buf;\\n        init(buf, capacity);\\n        append(buf, oldbuf);\\n    }\\n\\n    /**\\n    * @dev Sets buffer length to 0.\\n    * @param buf The buffer to truncate.\\n    * @return The original buffer, for chaining..\\n    */\\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n        assembly {\\n            let bufptr := mload(buf)\\n            mstore(bufptr, 0)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\\n        require(len <= data.length);\\n\\n        uint off = buf.buf.length;\\n        uint newCapacity = off + len;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n            // Update buffer length if we're extending it\\n            if gt(newCapacity, buflen) {\\n                mstore(bufptr, newCapacity)\\n            }\\n            src := add(data, 32)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint mask = (256 ** (32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n        return append(buf, data, data.length);\\n    }\\n\\n    /**\\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint offPlusOne = off + 1;\\n        if (off >= buf.capacity) {\\n            resize(buf, offPlusOne * 2);\\n        }\\n\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + sizeof(buffer length) + off\\n            let dest := add(add(bufptr, off), 32)\\n            mstore8(dest, data)\\n            // Update buffer length if we extended it\\n            if gt(offPlusOne, mload(bufptr)) {\\n                mstore(bufptr, offPlusOne)\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\\n    *      exceed the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (left-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint newCapacity = len + off;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        unchecked {\\n            uint mask = (256 ** len) - 1;\\n            // Right-align data\\n            data = data >> (8 * (32 - len));\\n            assembly {\\n                // Memory address of the buffer data\\n                let bufptr := mload(buf)\\n                // Address = buffer address + sizeof(buffer length) + newCapacity\\n                let dest := add(bufptr, newCapacity)\\n                mstore(dest, or(and(mload(dest), not(mask)), data))\\n                // Update buffer length if we extended it\\n                if gt(newCapacity, mload(bufptr)) {\\n                    mstore(bufptr, newCapacity)\\n                }\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chhaining.\\n    */\\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n        return append(buf, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n        return append(buf, data, 32);\\n    }\\n\\n    /**\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n     *      exceed the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @param len The number of bytes to write (right-aligned).\\n     * @return The original buffer.\\n     */\\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint newCapacity = len + off;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        uint mask = (256 ** len) - 1;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + sizeof(buffer length) + newCapacity\\n            let dest := add(bufptr, newCapacity)\\n            mstore(dest, or(and(mload(dest), not(mask)), data))\\n            // Update buffer length if we extended it\\n            if gt(newCapacity, mload(bufptr)) {\\n                mstore(bufptr, newCapacity)\\n            }\\n        }\\n        return buf;\\n    }\\n}\\n\",\"keccak256\":\"0xd6dd3b0b327288f8e1b711a609f4040fea602e2ad4bba9febdf2f33b4e56eb0c\",\"license\":\"BSD-2-Clause\"},\"@openzeppelin/contracts/access/AccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0dd6e52cb394d7f5abe5dca2d4908a6be40417914720932de757de34a99ab87f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\",\"keccak256\":\"0x59ce320a585d7e1f163cd70390a0ef2ff9cec832e2aa544293a00692465a7a57\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xba43b97fba0d32eb4254f6a5a297b39a19a247082a02d6e69349e071e2946218\",\"license\":\"MIT\"},\"@openzeppelin/contracts/security/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0xa535a5df777d44e945dd24aa43a11e44b024140fc340ad0dfe42acf4002aade1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xa82b58eca1ee256be466e536706850163d2ec7821945abd6b4778cfb3bee37da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Counters.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\",\"keccak256\":\"0xf0018c2440fbe238dd3a8732fa8e17a0f9dce84d31451dc8a32f6d62b349c9f1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\",\"keccak256\":\"0x809bc3edb4bcbef8263fa616c1b60ee0004b50a8a1bfa164d8f57fd31f520c58\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"@zondax/filecoin-solidity/contracts/v0.8/MarketAPI.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n//\\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.17;\\n\\nimport \\\"./types/MarketTypes.sol\\\";\\nimport \\\"./cbor/MarketCbor.sol\\\";\\nimport \\\"./cbor/BytesCbor.sol\\\";\\nimport \\\"./cbor/FilecoinCbor.sol\\\";\\n\\nimport \\\"./types/CommonTypes.sol\\\";\\nimport \\\"./utils/Misc.sol\\\";\\nimport \\\"./utils/Actor.sol\\\";\\n\\n/// @title This library is a proxy to the singleton Storage Market actor (address: f05). Calling one of its methods will result in a cross-actor call being performed.\\n/// @author Zondax AG\\nlibrary MarketAPI {\\n    using BytesCBOR for bytes;\\n    using MarketCBOR for *;\\n    using FilecoinCBOR for *;\\n\\n    /// @notice Deposits the received value into the balance held in escrow.\\n    function addBalance(CommonTypes.FilAddress memory providerOrClient, uint256 value) internal {\\n        bytes memory raw_request = providerOrClient.serializeAddress();\\n\\n        bytes memory data = Actor.callByID(MarketTypes.ActorID, MarketTypes.AddBalanceMethodNum, Misc.CBOR_CODEC, raw_request, value, false);\\n        if (data.length != 0) {\\n            revert Actor.InvalidResponseLength();\\n        }\\n    }\\n\\n    /// @notice Attempt to withdraw the specified amount from the balance held in escrow.\\n    /// @notice If less than the specified amount is available, yields the entire available balance.\\n    function withdrawBalance(MarketTypes.WithdrawBalanceParams memory params) internal returns (CommonTypes.BigInt memory) {\\n        bytes memory raw_request = params.serializeWithdrawBalanceParams();\\n\\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.WithdrawBalanceMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\\n\\n        return result.deserializeBytesBigInt();\\n    }\\n\\n    /// @notice Return the escrow balance and locked amount for an address.\\n    /// @return the escrow balance and locked amount for an address.\\n    function getBalance(CommonTypes.FilAddress memory addr) internal returns (MarketTypes.GetBalanceReturn memory) {\\n        bytes memory raw_request = addr.serializeAddress();\\n\\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetBalanceMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\\n\\n        return result.deserializeGetBalanceReturn();\\n    }\\n\\n    /// @notice This will be available after the deal is published (whether or not is is activated) and up until some undefined period after it is terminated.\\n    /// @return the data commitment and size of a deal proposal.\\n    function getDealDataCommitment(uint64 dealID) internal returns (MarketTypes.GetDealDataCommitmentReturn memory) {\\n        bytes memory raw_request = dealID.serializeDealID();\\n\\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealDataCommitmentMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\\n\\n        return result.deserializeGetDealDataCommitmentReturn();\\n    }\\n\\n    /// @notice get the client of the deal proposal.\\n    /// @return the client of a deal proposal.\\n    function getDealClient(uint64 dealID) internal returns (uint64) {\\n        bytes memory raw_request = dealID.serializeDealID();\\n\\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealClientMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\\n\\n        return result.deserializeUint64();\\n    }\\n\\n    /// @notice get the provider of a deal proposal.\\n    /// @return the provider of a deal proposal.\\n    function getDealProvider(uint64 dealID) internal returns (uint64) {\\n        bytes memory raw_request = dealID.serializeDealID();\\n\\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealProviderMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\\n\\n        return result.deserializeUint64();\\n    }\\n\\n    /// @notice Get the label of a deal proposal.\\n    /// @return the label of a deal proposal.\\n    function getDealLabel(uint64 dealID) internal returns (CommonTypes.DealLabel memory) {\\n        bytes memory raw_request = dealID.serializeDealID();\\n\\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealLabelMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\\n\\n        return result.deserializeDealLabel();\\n    }\\n\\n    /// @notice Get the start epoch and duration(in epochs) of a deal proposal.\\n    /// @return the start epoch and duration (in epochs) of a deal proposal.\\n    function getDealTerm(uint64 dealID) internal returns (MarketTypes.GetDealTermReturn memory) {\\n        bytes memory raw_request = dealID.serializeDealID();\\n\\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealTermMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\\n\\n        return result.deserializeGetDealTermReturn();\\n    }\\n\\n    /// @notice get the total price that will be paid from the client to the provider for this deal.\\n    /// @return the per-epoch price of a deal proposal.\\n    function getDealTotalPrice(uint64 dealID) internal returns (CommonTypes.BigInt memory) {\\n        bytes memory raw_request = dealID.serializeDealID();\\n\\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealTotalPriceMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\\n\\n        return result.deserializeBytesBigInt();\\n    }\\n\\n    /// @notice get the client collateral requirement for a deal proposal.\\n    /// @return the client collateral requirement for a deal proposal.\\n    function getDealClientCollateral(uint64 dealID) internal returns (CommonTypes.BigInt memory) {\\n        bytes memory raw_request = dealID.serializeDealID();\\n\\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealClientCollateralMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\\n\\n        return result.deserializeBytesBigInt();\\n    }\\n\\n    /// @notice get the provide collateral requirement for a deal proposal.\\n    /// @return the provider collateral requirement for a deal proposal.\\n    function getDealProviderCollateral(uint64 dealID) internal returns (CommonTypes.BigInt memory) {\\n        bytes memory raw_request = dealID.serializeDealID();\\n\\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealProviderCollateralMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\\n\\n        return result.deserializeBytesBigInt();\\n    }\\n\\n    /// @notice get the verified flag for a deal proposal.\\n    /// @notice Note that the source of truth for verified allocations and claims is the verified registry actor.\\n    /// @return the verified flag for a deal proposal.\\n    function getDealVerified(uint64 dealID) internal returns (bool) {\\n        bytes memory raw_request = dealID.serializeDealID();\\n\\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealVerifiedMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\\n\\n        return result.deserializeBool();\\n    }\\n\\n    /// @notice Fetches activation state for a deal.\\n    /// @notice This will be available from when the proposal is published until an undefined period after the deal finishes (either normally or by termination).\\n    /// @return USR_NOT_FOUND if the deal doesn't exist (yet), or EX_DEAL_EXPIRED if the deal has been removed from state.\\n    function getDealActivation(uint64 dealID) internal returns (MarketTypes.GetDealActivationReturn memory) {\\n        bytes memory raw_request = dealID.serializeDealID();\\n\\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealActivationMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\\n\\n        return result.deserializeGetDealActivationReturn();\\n    }\\n\\n    /// @notice Publish a new set of storage deals (not yet included in a sector).\\n    function publishStorageDeals(MarketTypes.PublishStorageDealsParams memory params) internal returns (MarketTypes.PublishStorageDealsReturn memory) {\\n        bytes memory raw_request = params.serializePublishStorageDealsParams();\\n\\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.PublishStorageDealsMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\\n\\n        return result.deserializePublishStorageDealsReturn();\\n    }\\n}\\n\",\"keccak256\":\"0xe2adcdda00cc16069016580c9ecfff6062f98315c40e4e584924d5808c4704fc\",\"license\":\"Apache-2.0\"},\"@zondax/filecoin-solidity/contracts/v0.8/cbor/BigIntCbor.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n//\\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.17;\\n\\nimport \\\"../types/CommonTypes.sol\\\";\\n\\n/// @title This library is a set of functions meant to handle CBOR serialization and deserialization for BigInt type\\n/// @author Zondax AG\\nlibrary BigIntCBOR {\\n    /// @notice serialize BigInt instance to bytes\\n    /// @param num BigInt instance to serialize\\n    /// @return serialized BigInt as bytes\\n    function serializeBigInt(CommonTypes.BigInt memory num) internal pure returns (bytes memory) {\\n        bytes memory raw = new bytes(num.val.length + 1);\\n\\n        raw[0] = num.neg == true ? bytes1(0x01) : bytes1(0x00);\\n\\n        uint index = 1;\\n        for (uint i = 0; i < num.val.length; i++) {\\n            raw[index] = num.val[i];\\n            index++;\\n        }\\n\\n        return raw;\\n    }\\n\\n    /// @notice deserialize big int (encoded as bytes) to BigInt instance\\n    /// @param raw as bytes to parse\\n    /// @return parsed BigInt instance\\n    function deserializeBigInt(bytes memory raw) internal pure returns (CommonTypes.BigInt memory) {\\n        if (raw.length == 0) {\\n            return CommonTypes.BigInt(hex\\\"00\\\", false);\\n        }\\n\\n        bytes memory val = new bytes(raw.length - 1);\\n        bool neg = false;\\n\\n        if (raw[0] == 0x01) {\\n            neg = true;\\n        }\\n\\n        for (uint i = 1; i < raw.length; i++) {\\n            val[i - 1] = raw[i];\\n        }\\n\\n        return CommonTypes.BigInt(val, neg);\\n    }\\n}\\n\",\"keccak256\":\"0xbe9eb7f33f943e12a2ca6d8a02178c30cef91f8c9db1c1b50f88a77e31784ac4\",\"license\":\"Apache-2.0\"},\"@zondax/filecoin-solidity/contracts/v0.8/cbor/BytesCbor.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n//\\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.17;\\n\\nimport \\\"solidity-cborutils/contracts/CBOR.sol\\\";\\n\\nimport \\\"../utils/CborDecode.sol\\\";\\nimport \\\"../utils/Misc.sol\\\";\\n\\nimport \\\"../types/CommonTypes.sol\\\";\\n\\nimport \\\"./BigIntCbor.sol\\\";\\n\\n/// @title This library is a set of functions meant to handle CBOR serialization and deserialization for bytes\\n/// @author Zondax AG\\nlibrary BytesCBOR {\\n    using CBOR for CBOR.CBORBuffer;\\n    using CBORDecoder for bytes;\\n    using BigIntCBOR for bytes;\\n\\n    /// @notice serialize raw bytes as cbor bytes string encoded\\n    /// @param data raw data in bytes\\n    /// @return encoded cbor bytes\\n    function serializeBytes(bytes memory data) internal pure returns (bytes memory) {\\n        uint256 capacity = Misc.getBytesSize(data);\\n\\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\\n\\n        buf.writeBytes(data);\\n\\n        return buf.data();\\n    }\\n\\n    /// @notice serialize raw address (in bytes) as cbor bytes string encoded (how an address is passed to filecoin actors)\\n    /// @param addr raw address in bytes\\n    /// @return encoded address as cbor bytes\\n    function serializeAddress(bytes memory addr) internal pure returns (bytes memory) {\\n        return serializeBytes(addr);\\n    }\\n\\n    /// @notice encoded null value as cbor\\n    /// @return cbor encoded null\\n    function serializeNull() internal pure returns (bytes memory) {\\n        CBOR.CBORBuffer memory buf = CBOR.create(1);\\n\\n        buf.writeNull();\\n\\n        return buf.data();\\n    }\\n\\n    /// @notice deserialize cbor encoded filecoin address to bytes\\n    /// @param ret cbor encoded filecoin address\\n    /// @return raw bytes representing a filecoin address\\n    function deserializeAddress(bytes memory ret) internal pure returns (bytes memory) {\\n        bytes memory addr;\\n        uint byteIdx = 0;\\n\\n        (addr, byteIdx) = ret.readBytes(byteIdx);\\n\\n        return addr;\\n    }\\n\\n    /// @notice deserialize cbor encoded string\\n    /// @param ret cbor encoded string (in bytes)\\n    /// @return decoded string\\n    function deserializeString(bytes memory ret) internal pure returns (string memory) {\\n        string memory response;\\n        uint byteIdx = 0;\\n\\n        (response, byteIdx) = ret.readString(byteIdx);\\n\\n        return response;\\n    }\\n\\n    /// @notice deserialize cbor encoded bool\\n    /// @param ret cbor encoded bool (in bytes)\\n    /// @return decoded bool\\n    function deserializeBool(bytes memory ret) internal pure returns (bool) {\\n        bool response;\\n        uint byteIdx = 0;\\n\\n        (response, byteIdx) = ret.readBool(byteIdx);\\n\\n        return response;\\n    }\\n\\n    /// @notice deserialize cbor encoded BigInt\\n    /// @param ret cbor encoded BigInt (in bytes)\\n    /// @return decoded BigInt\\n    /// @dev BigInts are cbor encoded as bytes string first. That is why it unwraps the cbor encoded bytes first, and then parse the result into BigInt\\n    function deserializeBytesBigInt(bytes memory ret) internal pure returns (CommonTypes.BigInt memory) {\\n        bytes memory tmp;\\n        uint byteIdx = 0;\\n\\n        if (ret.length > 0) {\\n            (tmp, byteIdx) = ret.readBytes(byteIdx);\\n            if (tmp.length > 0) {\\n                return tmp.deserializeBigInt();\\n            }\\n        }\\n\\n        return CommonTypes.BigInt(new bytes(0), false);\\n    }\\n\\n    /// @notice deserialize cbor encoded uint64\\n    /// @param rawResp cbor encoded uint64 (in bytes)\\n    /// @return decoded uint64\\n    function deserializeUint64(bytes memory rawResp) internal pure returns (uint64) {\\n        uint byteIdx = 0;\\n        uint64 value;\\n\\n        (value, byteIdx) = rawResp.readUInt64(byteIdx);\\n        return value;\\n    }\\n\\n    /// @notice deserialize cbor encoded int64\\n    /// @param rawResp cbor encoded int64 (in bytes)\\n    /// @return decoded int64\\n    function deserializeInt64(bytes memory rawResp) internal pure returns (int64) {\\n        uint byteIdx = 0;\\n        int64 value;\\n\\n        (value, byteIdx) = rawResp.readInt64(byteIdx);\\n        return value;\\n    }\\n}\\n\",\"keccak256\":\"0x092be34452eead511a33e8d5c0a0878bf53ac5747ada8788099a81bdf888eccf\",\"license\":\"Apache-2.0\"},\"@zondax/filecoin-solidity/contracts/v0.8/cbor/FilecoinCbor.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n//\\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.17;\\n\\nimport \\\"solidity-cborutils/contracts/CBOR.sol\\\";\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\n\\nimport \\\"../utils/CborDecode.sol\\\";\\nimport \\\"../utils/Misc.sol\\\";\\n\\nimport \\\"../types/CommonTypes.sol\\\";\\n\\nimport \\\"../cbor/BigIntCbor.sol\\\";\\n\\n/// @title This library is a set of functions meant to handle CBOR serialization and deserialization for general data types on the filecoin network.\\n/// @author Zondax AG\\nlibrary FilecoinCBOR {\\n    using Buffer for Buffer.buffer;\\n    using CBOR for CBOR.CBORBuffer;\\n    using CBORDecoder for *;\\n    using BigIntCBOR for *;\\n\\n    uint8 private constant MAJOR_TYPE_TAG = 6;\\n    uint8 private constant TAG_TYPE_CID_CODE = 42;\\n    uint8 private constant PAYLOAD_LEN_8_BITS = 24;\\n\\n    /// @notice Write a CID into a CBOR buffer.\\n    /// @dev The CBOR major will be 6 (type 'tag') and the tag type value is 42, as per CBOR tag assignments.\\n    /// @dev https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml\\n    /// @param buf buffer containing the actual CBOR serialization process\\n    /// @param value CID value to serialize as CBOR\\n    function writeCid(CBOR.CBORBuffer memory buf, bytes memory value) internal pure {\\n        buf.buf.appendUint8(uint8(((MAJOR_TYPE_TAG << 5) | PAYLOAD_LEN_8_BITS)));\\n        buf.buf.appendUint8(TAG_TYPE_CID_CODE);\\n        // See https://ipld.io/specs/codecs/dag-cbor/spec/#links for explanation on 0x00 prefix.\\n        buf.writeBytes(bytes.concat(hex'00', value));\\n    }\\n\\n    function readCid(bytes memory cborData, uint byteIdx) internal pure returns (CommonTypes.Cid memory, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = cborData.parseCborHeader(byteIdx);\\n        require(maj == MAJOR_TYPE_TAG, \\\"expected major type tag when parsing cid\\\");\\n        require(value == TAG_TYPE_CID_CODE, \\\"expected tag 42 when parsing cid\\\");\\n\\n        bytes memory raw;\\n        (raw, byteIdx) = cborData.readBytes(byteIdx);\\n        require(raw[0] == 0x00, \\\"expected first byte to be 0 when parsing cid\\\");\\n\\n        // Pop off the first byte, which corresponds to the historical multibase 0x00 byte.\\n        // https://ipld.io/specs/codecs/dag-cbor/spec/#links\\n        CommonTypes.Cid memory ret;\\n        ret.data = new bytes(raw.length - 1);\\n        for (uint256 i = 1; i < raw.length; i++) {\\n            ret.data[i-1] = raw[i];\\n        }\\n\\n        return (ret, byteIdx);\\n    }\\n\\n    /// @notice serialize filecoin address to cbor encoded\\n    /// @param addr filecoin address to serialize\\n    /// @return cbor serialized data as bytes\\n    function serializeAddress(CommonTypes.FilAddress memory addr) internal pure returns (bytes memory) {\\n        uint256 capacity = Misc.getBytesSize(addr.data);\\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\\n\\n        buf.writeBytes(addr.data);\\n\\n        return buf.data();\\n    }\\n\\n    /// @notice serialize a BigInt value wrapped in a cbor fixed array.\\n    /// @param value BigInt to serialize as cbor inside an\\n    /// @return cbor serialized data as bytes\\n    function serializeArrayBigInt(CommonTypes.BigInt memory value) internal pure returns (bytes memory) {\\n        uint256 capacity = 0;\\n        bytes memory valueBigInt = value.serializeBigInt();\\n\\n        capacity += Misc.getPrefixSize(1);\\n        capacity += Misc.getBytesSize(valueBigInt);\\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\\n\\n        buf.startFixedArray(1);\\n        buf.writeBytes(value.serializeBigInt());\\n\\n        return buf.data();\\n    }\\n\\n    /// @notice serialize a FilAddress value wrapped in a cbor fixed array.\\n    /// @param addr FilAddress to serialize as cbor inside an\\n    /// @return cbor serialized data as bytes\\n    function serializeArrayFilAddress(CommonTypes.FilAddress memory addr) internal pure returns (bytes memory) {\\n        uint256 capacity = 0;\\n\\n        capacity += Misc.getPrefixSize(1);\\n        capacity += Misc.getBytesSize(addr.data);\\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\\n\\n        buf.startFixedArray(1);\\n        buf.writeBytes(addr.data);\\n\\n        return buf.data();\\n    }\\n\\n    /// @notice deserialize a FilAddress wrapped on a cbor fixed array coming from a actor call\\n    /// @param rawResp cbor encoded response\\n    /// @return ret new instance of FilAddress created based on parsed data\\n    function deserializeArrayFilAddress(bytes memory rawResp) internal pure returns (CommonTypes.FilAddress memory ret) {\\n        uint byteIdx = 0;\\n        uint len;\\n\\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\\n        require(len == 1, \\\"Wrong numbers of parameters (should find 1)\\\");\\n\\n        (ret.data, byteIdx) = rawResp.readBytes(byteIdx);\\n\\n        return ret;\\n    }\\n\\n    /// @notice deserialize a BigInt wrapped on a cbor fixed array coming from a actor call\\n    /// @param rawResp cbor encoded response\\n    /// @return ret new instance of BigInt created based on parsed data\\n    function deserializeArrayBigInt(bytes memory rawResp) internal pure returns (CommonTypes.BigInt memory) {\\n        uint byteIdx = 0;\\n        uint len;\\n        bytes memory tmp;\\n\\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\\n        assert(len == 1);\\n\\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\\n        return tmp.deserializeBigInt();\\n    }\\n\\n    /// @notice serialize UniversalReceiverParams struct to cbor in order to pass as arguments to an actor\\n    /// @param params UniversalReceiverParams to serialize as cbor\\n    /// @return cbor serialized data as bytes\\n    function serializeUniversalReceiverParams(CommonTypes.UniversalReceiverParams memory params) internal pure returns (bytes memory) {\\n        uint256 capacity = 0;\\n\\n        capacity += Misc.getPrefixSize(2);\\n        capacity += Misc.getPrefixSize(params.type_);\\n        capacity += Misc.getBytesSize(params.payload);\\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\\n\\n        buf.startFixedArray(2);\\n        buf.writeUInt64(params.type_);\\n        buf.writeBytes(params.payload);\\n\\n        return buf.data();\\n    }\\n\\n    /// @notice deserialize UniversalReceiverParams cbor to struct when receiving a message\\n    /// @param rawResp cbor encoded response\\n    /// @return ret new instance of UniversalReceiverParams created based on parsed data\\n    function deserializeUniversalReceiverParams(bytes memory rawResp) internal pure returns (CommonTypes.UniversalReceiverParams memory ret) {\\n        uint byteIdx = 0;\\n        uint len;\\n\\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\\n        require(len == 2, \\\"Wrong numbers of parameters (should find 2)\\\");\\n\\n        (ret.type_, byteIdx) = rawResp.readUInt32(byteIdx);\\n        (ret.payload, byteIdx) = rawResp.readBytes(byteIdx);\\n    }\\n\\n    /// @notice attempt to read a FilActorId value\\n    /// @param rawResp cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    /// @return a FilActorId decoded from input bytes and the byte index after moving past the value\\n    function readFilActorId(bytes memory rawResp, uint byteIdx) internal pure returns (CommonTypes.FilActorId, uint) {\\n        uint64 tmp = 0;\\n\\n        (tmp, byteIdx) = rawResp.readUInt64(byteIdx);\\n        return (CommonTypes.FilActorId.wrap(tmp), byteIdx);\\n    }\\n\\n    /// @notice write FilActorId into a cbor buffer\\n    /// @dev FilActorId is just wrapping a uint64\\n    /// @param buf buffer containing the actual cbor serialization process\\n    /// @param id FilActorId to serialize as cbor\\n    function writeFilActorId(CBOR.CBORBuffer memory buf, CommonTypes.FilActorId id) internal pure {\\n        buf.writeUInt64(CommonTypes.FilActorId.unwrap(id));\\n    }\\n\\n    /// @notice attempt to read a ChainEpoch value\\n    /// @param rawResp cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    /// @return a ChainEpoch decoded from input bytes and the byte index after moving past the value\\n    function readChainEpoch(bytes memory rawResp, uint byteIdx) internal pure returns (CommonTypes.ChainEpoch, uint) {\\n        int64 tmp = 0;\\n\\n        (tmp, byteIdx) = rawResp.readInt64(byteIdx);\\n        return (CommonTypes.ChainEpoch.wrap(tmp), byteIdx);\\n    }\\n\\n    /// @notice write ChainEpoch into a cbor buffer\\n    /// @dev ChainEpoch is just wrapping a int64\\n    /// @param buf buffer containing the actual cbor serialization process\\n    /// @param id ChainEpoch to serialize as cbor\\n    function writeChainEpoch(CBOR.CBORBuffer memory buf, CommonTypes.ChainEpoch id) internal pure {\\n        buf.writeInt64(CommonTypes.ChainEpoch.unwrap(id));\\n    }\\n\\n    /// @notice write DealLabel into a cbor buffer\\n    /// @param buf buffer containing the actual cbor serialization process\\n    /// @param label DealLabel to serialize as cbor\\n    function writeDealLabel(CBOR.CBORBuffer memory buf, CommonTypes.DealLabel memory label) internal pure {\\n        label.isString ? buf.writeString(string(label.data)) : buf.writeBytes(label.data);\\n    }\\n\\n    /// @notice deserialize DealLabel cbor to struct when receiving a message\\n    /// @param rawResp cbor encoded response\\n    /// @return ret new instance of DealLabel created based on parsed data\\n    function deserializeDealLabel(bytes memory rawResp) internal pure returns (CommonTypes.DealLabel memory) {\\n        uint byteIdx = 0;\\n        CommonTypes.DealLabel memory label;\\n\\n        (label, byteIdx) = readDealLabel(rawResp, byteIdx);\\n        return label;\\n    }\\n\\n    /// @notice attempt to read a DealLabel value\\n    /// @param rawResp cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    /// @return a DealLabel decoded from input bytes and the byte index after moving past the value\\n    function readDealLabel(bytes memory rawResp, uint byteIdx) internal pure returns (CommonTypes.DealLabel memory, uint) {\\n        uint8 maj;\\n        uint len;\\n\\n        (maj, len, byteIdx) = CBORDecoder.parseCborHeader(rawResp, byteIdx);\\n        require(maj == MajByteString || maj == MajTextString, \\\"invalid maj (expected MajByteString or MajTextString)\\\");\\n\\n        uint max_len = byteIdx + len;\\n        bytes memory slice = new bytes(len);\\n        uint slice_index = 0;\\n        for (uint256 i = byteIdx; i < max_len; i++) {\\n            slice[slice_index] = rawResp[i];\\n            slice_index++;\\n        }\\n\\n        return (CommonTypes.DealLabel(slice, maj == MajTextString), byteIdx + len);\\n    }\\n}\\n\",\"keccak256\":\"0x9c73c2969df5325f1f86c401b05b8983e633e8bd21c1c72b2b9039a731174098\",\"license\":\"Apache-2.0\"},\"@zondax/filecoin-solidity/contracts/v0.8/cbor/MarketCbor.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n//\\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.17;\\n\\nimport \\\"solidity-cborutils/contracts/CBOR.sol\\\";\\n\\nimport \\\"../types/MarketTypes.sol\\\";\\nimport \\\"../types/CommonTypes.sol\\\";\\n\\nimport \\\"../utils/Misc.sol\\\";\\nimport \\\"../utils/FilAddresses.sol\\\";\\nimport \\\"../utils/CborDecode.sol\\\";\\n\\nimport \\\"./FilecoinCbor.sol\\\";\\nimport \\\"./BigIntCbor.sol\\\";\\nimport \\\"./FilecoinCbor.sol\\\";\\n\\n/// @title This library is a set of functions meant to handle CBOR parameters serialization and return values deserialization for Market actor exported methods.\\n/// @author Zondax AG\\nlibrary MarketCBOR {\\n    using CBOR for CBOR.CBORBuffer;\\n    using CBORDecoder for bytes;\\n    using BigIntCBOR for *;\\n    using FilecoinCBOR for *;\\n\\n    /// @notice serialize WithdrawBalanceParams struct to cbor in order to pass as arguments to the market actor\\n    /// @param params WithdrawBalanceParams to serialize as cbor\\n    /// @return response cbor serialized data as bytes\\n    function serializeWithdrawBalanceParams(MarketTypes.WithdrawBalanceParams memory params) internal pure returns (bytes memory) {\\n        uint256 capacity = 0;\\n        bytes memory tokenAmount = params.tokenAmount.serializeBigInt();\\n\\n        capacity += Misc.getPrefixSize(2);\\n        capacity += Misc.getBytesSize(params.provider_or_client.data);\\n        capacity += Misc.getBytesSize(tokenAmount);\\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\\n\\n        buf.startFixedArray(2);\\n        buf.writeBytes(params.provider_or_client.data);\\n        buf.writeBytes(tokenAmount);\\n\\n        return buf.data();\\n    }\\n\\n    /// @notice deserialize GetBalanceReturn struct from cbor encoded bytes coming from a market actor call\\n    /// @param rawResp cbor encoded response\\n    /// @return ret new instance of GetBalanceReturn created based on parsed data\\n    function deserializeGetBalanceReturn(bytes memory rawResp) internal pure returns (MarketTypes.GetBalanceReturn memory ret) {\\n        uint byteIdx = 0;\\n        uint len;\\n        bytes memory tmp;\\n\\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\\n        assert(len == 2);\\n\\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\\n        ret.balance = tmp.deserializeBigInt();\\n\\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\\n        ret.locked = tmp.deserializeBigInt();\\n\\n        return ret;\\n    }\\n\\n    /// @notice deserialize GetDealDataCommitmentReturn struct from cbor encoded bytes coming from a market actor call\\n    /// @param rawResp cbor encoded response\\n    /// @return ret new instance of GetDealDataCommitmentReturn created based on parsed data\\n    function deserializeGetDealDataCommitmentReturn(bytes memory rawResp) internal pure returns (MarketTypes.GetDealDataCommitmentReturn memory ret) {\\n        uint byteIdx = 0;\\n        uint len;\\n\\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\\n\\n        if (len > 0) {\\n            (ret.data, byteIdx) = rawResp.readBytes(byteIdx);\\n            (ret.size, byteIdx) = rawResp.readUInt64(byteIdx);\\n        } else {\\n            ret.data = new bytes(0);\\n            ret.size = 0;\\n        }\\n\\n        return ret;\\n    }\\n\\n    /// @notice deserialize GetDealTermReturn struct from cbor encoded bytes coming from a market actor call\\n    /// @param rawResp cbor encoded response\\n    /// @return ret new instance of GetDealTermReturn created based on parsed data\\n    function deserializeGetDealTermReturn(bytes memory rawResp) internal pure returns (MarketTypes.GetDealTermReturn memory ret) {\\n        uint byteIdx = 0;\\n        uint len;\\n\\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\\n        assert(len == 2);\\n\\n        (ret.start, byteIdx) = rawResp.readChainEpoch(byteIdx);\\n        (ret.end, byteIdx) = rawResp.readChainEpoch(byteIdx);\\n\\n        return ret;\\n    }\\n\\n    /// @notice deserialize GetDealActivationReturn struct from cbor encoded bytes coming from a market actor call\\n    /// @param rawResp cbor encoded response\\n    /// @return ret new instance of GetDealActivationReturn created based on parsed data\\n    function deserializeGetDealActivationReturn(bytes memory rawResp) internal pure returns (MarketTypes.GetDealActivationReturn memory ret) {\\n        uint byteIdx = 0;\\n        uint len;\\n\\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\\n        assert(len == 2);\\n\\n        (ret.activated, byteIdx) = rawResp.readChainEpoch(byteIdx);\\n        (ret.terminated, byteIdx) = rawResp.readChainEpoch(byteIdx);\\n\\n        return ret;\\n    }\\n\\n    /// @notice serialize PublishStorageDealsParams struct to cbor in order to pass as arguments to the market actor\\n    /// @param params PublishStorageDealsParams to serialize as cbor\\n    /// @return cbor serialized data as bytes\\n    function serializePublishStorageDealsParams(MarketTypes.PublishStorageDealsParams memory params) internal pure returns (bytes memory) {\\n        uint256 capacity = 0;\\n\\n        capacity += Misc.getPrefixSize(1);\\n        capacity += Misc.getPrefixSize(params.deals.length);\\n\\n        for (uint64 i = 0; i < params.deals.length; i++) {\\n            capacity += Misc.getPrefixSize(2);\\n            capacity += Misc.getPrefixSize(11);\\n\\n            capacity += Misc.getCidSize(params.deals[i].proposal.piece_cid.data);\\n            capacity += Misc.getPrefixSize(params.deals[i].proposal.piece_size);\\n            capacity += Misc.getBoolSize();\\n            capacity += Misc.getBytesSize(params.deals[i].proposal.client.data);\\n            capacity += Misc.getBytesSize(params.deals[i].proposal.provider.data);\\n            capacity += Misc.getBytesSize(params.deals[i].proposal.label.data);\\n            capacity += Misc.getChainEpochSize(params.deals[i].proposal.start_epoch);\\n            capacity += Misc.getChainEpochSize(params.deals[i].proposal.end_epoch);\\n            capacity += Misc.getBytesSize(params.deals[i].proposal.storage_price_per_epoch.serializeBigInt());\\n            capacity += Misc.getBytesSize(params.deals[i].proposal.provider_collateral.serializeBigInt());\\n            capacity += Misc.getBytesSize(params.deals[i].proposal.client_collateral.serializeBigInt());\\n\\n            capacity += Misc.getBytesSize(params.deals[i].client_signature);\\n        }\\n\\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\\n\\n        buf.startFixedArray(1);\\n        buf.startFixedArray(uint64(params.deals.length));\\n\\n        for (uint64 i = 0; i < params.deals.length; i++) {\\n            buf.startFixedArray(2);\\n\\n            buf.startFixedArray(11);\\n\\n            buf.writeCid(params.deals[i].proposal.piece_cid.data);\\n            buf.writeUInt64(params.deals[i].proposal.piece_size);\\n            buf.writeBool(params.deals[i].proposal.verified_deal);\\n            buf.writeBytes(params.deals[i].proposal.client.data);\\n            buf.writeBytes(params.deals[i].proposal.provider.data);\\n            buf.writeDealLabel(params.deals[i].proposal.label);\\n            buf.writeChainEpoch(params.deals[i].proposal.start_epoch);\\n            buf.writeChainEpoch(params.deals[i].proposal.end_epoch);\\n            buf.writeBytes(params.deals[i].proposal.storage_price_per_epoch.serializeBigInt());\\n            buf.writeBytes(params.deals[i].proposal.provider_collateral.serializeBigInt());\\n            buf.writeBytes(params.deals[i].proposal.client_collateral.serializeBigInt());\\n\\n            buf.writeBytes(params.deals[i].client_signature);\\n        }\\n\\n        return buf.data();\\n    }\\n\\n    /// @notice deserialize PublishStorageDealsReturn struct from cbor encoded bytes coming from a market actor call\\n    /// @param rawResp cbor encoded response\\n    /// @return ret new instance of PublishStorageDealsReturn created based on parsed data\\n    function deserializePublishStorageDealsReturn(bytes memory rawResp) internal pure returns (MarketTypes.PublishStorageDealsReturn memory ret) {\\n        uint byteIdx = 0;\\n        uint len;\\n\\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\\n        assert(len == 2);\\n\\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\\n        ret.ids = new uint64[](len);\\n\\n        for (uint i = 0; i < len; i++) {\\n            (ret.ids[i], byteIdx) = rawResp.readUInt64(byteIdx);\\n        }\\n\\n        (ret.valid_deals, byteIdx) = rawResp.readBytes(byteIdx);\\n\\n        return ret;\\n    }\\n\\n    /// @notice serialize deal id (uint64) to cbor in order to pass as arguments to the market actor\\n    /// @param id deal id to serialize as cbor\\n    /// @return cbor serialized data as bytes\\n    function serializeDealID(uint64 id) internal pure returns (bytes memory) {\\n        uint256 capacity = Misc.getPrefixSize(uint256(id));\\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\\n\\n        buf.writeUInt64(id);\\n\\n        return buf.data();\\n    }\\n\\n    function deserializeMarketDealNotifyParams(bytes memory rawResp) internal pure returns (MarketTypes.MarketDealNotifyParams memory ret) {\\n        uint byteIdx = 0;\\n        uint len;\\n\\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\\n        assert(len == 2);\\n\\n        (ret.dealProposal, byteIdx) = rawResp.readBytes(byteIdx);\\n        (ret.dealId, byteIdx) = rawResp.readUInt64(byteIdx);\\n    }\\n\\n    function serializeDealProposal(MarketTypes.DealProposal memory dealProposal) internal pure returns (bytes memory) {\\n        uint256 capacity = 0;\\n        bytes memory storage_price_per_epoch = dealProposal.storage_price_per_epoch.serializeBigInt();\\n        bytes memory provider_collateral = dealProposal.provider_collateral.serializeBigInt();\\n        bytes memory client_collateral = dealProposal.client_collateral.serializeBigInt();\\n\\n        capacity += Misc.getPrefixSize(11);\\n        capacity += Misc.getCidSize(dealProposal.piece_cid.data);\\n        capacity += Misc.getPrefixSize(dealProposal.piece_size);\\n        capacity += Misc.getBoolSize();\\n        capacity += Misc.getBytesSize(dealProposal.client.data);\\n        capacity += Misc.getBytesSize(dealProposal.provider.data);\\n        capacity += Misc.getBytesSize(dealProposal.label.data);\\n        capacity += Misc.getChainEpochSize(dealProposal.start_epoch);\\n        capacity += Misc.getChainEpochSize(dealProposal.end_epoch);\\n        capacity += Misc.getBytesSize(storage_price_per_epoch);\\n        capacity += Misc.getBytesSize(provider_collateral);\\n        capacity += Misc.getBytesSize(client_collateral);\\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\\n\\n        buf.startFixedArray(11);\\n\\n        buf.writeCid(dealProposal.piece_cid.data);\\n        buf.writeUInt64(dealProposal.piece_size);\\n        buf.writeBool(dealProposal.verified_deal);\\n        buf.writeBytes(dealProposal.client.data);\\n        buf.writeBytes(dealProposal.provider.data);\\n        buf.writeDealLabel(dealProposal.label);\\n        buf.writeChainEpoch(dealProposal.start_epoch);\\n        buf.writeChainEpoch(dealProposal.end_epoch);\\n        buf.writeBytes(storage_price_per_epoch);\\n        buf.writeBytes(provider_collateral);\\n        buf.writeBytes(client_collateral);\\n\\n        return buf.data();\\n    }\\n\\n    function deserializeDealProposal(bytes memory rawResp) internal pure returns (MarketTypes.DealProposal memory ret) {\\n        uint byteIdx = 0;\\n        uint len;\\n        bytes memory tmp;\\n\\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\\n        assert(len == 11);\\n\\n        (ret.piece_cid, byteIdx) = rawResp.readCid(byteIdx);\\n        (ret.piece_size, byteIdx) = rawResp.readUInt64(byteIdx);\\n        (ret.verified_deal, byteIdx) = rawResp.readBool(byteIdx);\\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\\n        ret.client = FilAddresses.fromBytes(tmp);\\n\\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\\n        ret.provider = FilAddresses.fromBytes(tmp);\\n\\n        (ret.label, byteIdx) = rawResp.readDealLabel(byteIdx);\\n\\n        (ret.start_epoch, byteIdx) = rawResp.readChainEpoch(byteIdx);\\n        (ret.end_epoch, byteIdx) = rawResp.readChainEpoch(byteIdx);\\n\\n        bytes memory storage_price_per_epoch_bytes;\\n        (storage_price_per_epoch_bytes, byteIdx) = rawResp.readBytes(byteIdx);\\n        ret.storage_price_per_epoch = storage_price_per_epoch_bytes.deserializeBigInt();\\n\\n        bytes memory provider_collateral_bytes;\\n        (provider_collateral_bytes, byteIdx) = rawResp.readBytes(byteIdx);\\n        ret.provider_collateral = provider_collateral_bytes.deserializeBigInt();\\n\\n        bytes memory client_collateral_bytes;\\n        (client_collateral_bytes, byteIdx) = rawResp.readBytes(byteIdx);\\n        ret.client_collateral = client_collateral_bytes.deserializeBigInt();\\n    }\\n}\\n\",\"keccak256\":\"0x181e7688efec53b7b300ac9423ff0211dab43e1092340f4905f6528fbd30023a\",\"license\":\"Apache-2.0\"},\"@zondax/filecoin-solidity/contracts/v0.8/types/CommonTypes.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n//\\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.17;\\n\\n\\n/// @title Filecoin actors' common types for Solidity.\\n/// @author Zondax AG\\nlibrary CommonTypes {\\n    uint constant UniversalReceiverHookMethodNum = 3726118371;\\n\\n    /// @param idx index for the failure in batch\\n    /// @param code failure code\\n    struct FailCode {\\n        uint32 idx;\\n        uint32 code;\\n    }\\n\\n    /// @param success_count total successes in batch\\n    /// @param fail_codes list of failures code and index for each failure in batch\\n    struct BatchReturn {\\n        uint32 success_count;\\n        FailCode[] fail_codes;\\n    }\\n\\n    /// @param type_ asset type\\n    /// @param payload payload corresponding to asset type\\n    struct UniversalReceiverParams {\\n        uint32 type_;\\n        bytes payload;\\n    }\\n\\n    /// @param val contains the actual arbitrary number written as binary\\n    /// @param neg indicates if val is negative or not\\n    struct BigInt {\\n        bytes val;\\n        bool neg;\\n    }\\n\\n    /// @param data filecoin address in bytes format\\n    struct FilAddress {\\n        bytes data;\\n    }\\n\\n    /// @param data cid in bytes format\\n    struct Cid {\\n        bytes data;\\n    }\\n\\n    /// @param data deal proposal label in bytes format (it can be utf8 string or arbitrary bytes string).\\n    /// @param isString indicates if the data is string or raw bytes\\n    struct DealLabel {\\n        bytes data;\\n        bool isString;\\n    }\\n\\n    type FilActorId is uint64;\\n\\n    type ChainEpoch is int64;\\n}\\n\",\"keccak256\":\"0x1819b8e82cf53f0fadc446d064a380979888b97a0004f1e70c9fa1a6f4f13ed9\",\"license\":\"Apache-2.0\"},\"@zondax/filecoin-solidity/contracts/v0.8/types/MarketTypes.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n//\\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.17;\\n\\nimport \\\"../cbor/BigIntCbor.sol\\\";\\nimport \\\"./CommonTypes.sol\\\";\\n\\n/// @title Filecoin market actor types for Solidity.\\n/// @author Zondax AG\\nlibrary MarketTypes {\\n    CommonTypes.FilActorId constant ActorID = CommonTypes.FilActorId.wrap(5);\\n    uint constant AddBalanceMethodNum = 822473126;\\n    uint constant WithdrawBalanceMethodNum = 2280458852;\\n    uint constant GetBalanceMethodNum = 726108461;\\n    uint constant GetDealDataCommitmentMethodNum = 1157985802;\\n    uint constant GetDealClientMethodNum = 128053329;\\n    uint constant GetDealProviderMethodNum = 935081690;\\n    uint constant GetDealLabelMethodNum = 46363526;\\n    uint constant GetDealTermMethodNum = 163777312;\\n    uint constant GetDealTotalPriceMethodNum = 4287162428;\\n    uint constant GetDealClientCollateralMethodNum = 200567895;\\n    uint constant GetDealProviderCollateralMethodNum = 2986712137;\\n    uint constant GetDealVerifiedMethodNum = 2627389465;\\n    uint constant GetDealActivationMethodNum = 2567238399;\\n    uint constant PublishStorageDealsMethodNum = 2236929350;\\n\\n    /// @param provider_or_client the address of provider or client.\\n    /// @param tokenAmount the token amount to withdraw.\\n    struct WithdrawBalanceParams {\\n        CommonTypes.FilAddress provider_or_client;\\n        CommonTypes.BigInt tokenAmount;\\n    }\\n\\n    /// @param balance the escrow balance for this address.\\n    /// @param locked the escrow locked amount for this address.\\n    struct GetBalanceReturn {\\n        CommonTypes.BigInt balance;\\n        CommonTypes.BigInt locked;\\n    }\\n\\n    /// @param data the data commitment of this deal.\\n    /// @param size the size of this deal.\\n    struct GetDealDataCommitmentReturn {\\n        bytes data;\\n        uint64 size;\\n    }\\n\\n    /// @param start the chain epoch to start the deal.\\n    /// @param endthe chain epoch to end the deal.\\n    struct GetDealTermReturn {\\n        CommonTypes.ChainEpoch start;\\n        CommonTypes.ChainEpoch end;\\n    }\\n\\n    /// @param activated Epoch at which the deal was activated, or -1.\\n    /// @param terminated Epoch at which the deal was terminated abnormally, or -1.\\n    struct GetDealActivationReturn {\\n        CommonTypes.ChainEpoch activated;\\n        CommonTypes.ChainEpoch terminated;\\n    }\\n\\n    /// @param deals list of deal proposals signed by a client\\n    struct PublishStorageDealsParams {\\n        ClientDealProposal[] deals;\\n    }\\n\\n    /// @param ids returned storage deal IDs.\\n    /// @param valid_deals represent all the valid deals.\\n    struct PublishStorageDealsReturn {\\n        uint64[] ids;\\n        bytes valid_deals;\\n    }\\n\\n    /// @param piece_cid PieceCID.\\n    /// @param piece_size the size of the piece.\\n    /// @param verified_deal if the deal is verified or not.\\n    /// @param client the address of the storage client.\\n    /// @param provider the address of the storage provider.\\n    /// @param label any label that client choose for the deal.\\n    /// @param start_epoch the chain epoch to start the deal.\\n    /// @param end_epoch the chain epoch to end the deal.\\n    /// @param storage_price_per_epoch the token amount to pay to provider per epoch.\\n    /// @param provider_collateral the token amount as collateral paid by the provider.\\n    /// @param client_collateral the token amount as collateral paid by the client.\\n    struct DealProposal {\\n        CommonTypes.Cid piece_cid;\\n        uint64 piece_size;\\n        bool verified_deal;\\n        CommonTypes.FilAddress client;\\n        CommonTypes.FilAddress provider;\\n        CommonTypes.DealLabel label;\\n        CommonTypes.ChainEpoch start_epoch;\\n        CommonTypes.ChainEpoch end_epoch;\\n        CommonTypes.BigInt storage_price_per_epoch;\\n        CommonTypes.BigInt provider_collateral;\\n        CommonTypes.BigInt client_collateral;\\n    }\\n\\n    /// @param proposal Proposal\\n    /// @param client_signature the signature signed by the client.\\n    struct ClientDealProposal {\\n        DealProposal proposal;\\n        bytes client_signature;\\n    }\\n\\n    struct MarketDealNotifyParams {\\n        bytes dealProposal;\\n        uint64 dealId;\\n    }\\n}\\n\",\"keccak256\":\"0xcbffb585561b6057c72c1e1cfea6090d918341cc347e785a988ee9c3c70533be\",\"license\":\"Apache-2.0\"},\"@zondax/filecoin-solidity/contracts/v0.8/utils/Actor.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.17;\\n\\nimport \\\"./Misc.sol\\\";\\nimport \\\"../types/CommonTypes.sol\\\";\\n\\n/// @title Call actors utilities library, meant to interact with Filecoin builtin actors\\n/// @author Zondax AG\\nlibrary Actor {\\n    /// @notice precompile address for the call_actor precompile\\n    address constant CALL_ACTOR_ADDRESS = 0xfe00000000000000000000000000000000000003;\\n\\n    /// @notice precompile address for the call_actor_id precompile\\n    address constant CALL_ACTOR_ID = 0xfe00000000000000000000000000000000000005;\\n\\n    /// @notice flag used to indicate that the call_actor or call_actor_id should perform a static_call to the desired actor\\n    uint64 constant READ_ONLY_FLAG = 0x00000001;\\n\\n    /// @notice flag used to indicate that the call_actor or call_actor_id should perform a call to the desired actor\\n    uint64 constant DEFAULT_FLAG = 0x00000000;\\n\\n    /// @notice the provided address is not valid\\n    error InvalidAddress(bytes addr);\\n\\n    /// @notice the smart contract has no enough balance to transfer\\n    error NotEnoughBalance(uint256 balance, uint256 value);\\n\\n    /// @notice the provided actor id is not valid\\n    error InvalidActorID(CommonTypes.FilActorId actorId);\\n\\n    /// @notice an error happened trying to call the actor\\n    error FailToCallActor();\\n\\n    /// @notice the response received is not correct. In some case no response is expected and we received one, or a response was indeed expected and we received none.\\n    error InvalidResponseLength();\\n\\n    /// @notice the codec received is not valid\\n    error InvalidCodec(uint64);\\n\\n    /// @notice the called actor returned an error as part of its expected behaviour\\n    error ActorError(int256 errorCode);\\n\\n    /// @notice the actor is not found\\n    error ActorNotFound();\\n\\n    /// @notice allows to interact with an specific actor by its address (bytes format)\\n    /// @param actor_address actor address (bytes format) to interact with\\n    /// @param method_num id of the method from the actor to call\\n    /// @param codec how the request data passed as argument is encoded\\n    /// @param raw_request encoded arguments to be passed in the call\\n    /// @param value tokens to be transferred to the called actor\\n    /// @param static_call indicates if the call will be allowed to change the actor state or not (just read the state)\\n    /// @return payload (in bytes) with the actual response data (without codec or response code)\\n    function callByAddress(\\n        bytes memory actor_address,\\n        uint256 method_num,\\n        uint64 codec,\\n        bytes memory raw_request,\\n        uint256 value,\\n        bool static_call\\n    ) internal returns (bytes memory) {\\n        if (actor_address.length < 2) {\\n            revert InvalidAddress(actor_address);\\n        }\\n\\n        validatePrecompileCall(CALL_ACTOR_ADDRESS, value);\\n\\n        // We have to delegate-call the call-actor precompile because the call-actor precompile will\\n        // call the target actor on our behalf. This will _not_ delegate to the target `actor_address`.\\n        //\\n        // Specifically:\\n        //\\n        // - `static_call == false`: `CALLER (you) --(DELEGATECALL)-> CALL_ACTOR_PRECOMPILE --(CALL)-> actor_address\\n        // - `static_call == true`:  `CALLER (you) --(DELEGATECALL)-> CALL_ACTOR_PRECOMPILE --(STATICCALL)-> actor_address\\n        (bool success, bytes memory data) = address(CALL_ACTOR_ADDRESS).delegatecall(\\n            abi.encode(uint64(method_num), value, static_call ? READ_ONLY_FLAG : DEFAULT_FLAG, codec, raw_request, actor_address)\\n        );\\n        if (!success) {\\n            revert FailToCallActor();\\n        }\\n\\n        return readRespData(data);\\n    }\\n\\n    /// @notice allows to interact with an specific actor by its id (uint64)\\n    /// @param target actor id (uint64) to interact with\\n    /// @param method_num id of the method from the actor to call\\n    /// @param codec how the request data passed as argument is encoded\\n    /// @param raw_request encoded arguments to be passed in the call\\n    /// @param value tokens to be transferred to the called actor\\n    /// @param static_call indicates if the call will be allowed to change the actor state or not (just read the state)\\n    /// @return payload (in bytes) with the actual response data (without codec or response code)\\n    function callByID(\\n        CommonTypes.FilActorId target,\\n        uint256 method_num,\\n        uint64 codec,\\n        bytes memory raw_request,\\n        uint256 value,\\n        bool static_call\\n    ) internal returns (bytes memory) {\\n        validatePrecompileCall(CALL_ACTOR_ID, value);\\n\\n        (bool success, bytes memory data) = address(CALL_ACTOR_ID).delegatecall(\\n            abi.encode(uint64(method_num), value, static_call ? READ_ONLY_FLAG : DEFAULT_FLAG, codec, raw_request, target)\\n        );\\n        if (!success) {\\n            revert FailToCallActor();\\n        }\\n\\n        return readRespData(data);\\n    }\\n\\n    /// @notice allows to run some generic validations before calling the precompile actor\\n    /// @param addr precompile actor address to run check to\\n    /// @param value tokens to be transferred to the called actor\\n    function validatePrecompileCall(address addr, uint256 value) internal view {\\n        uint balance = address(this).balance;\\n        if (balance < value) {\\n            revert NotEnoughBalance(balance, value);\\n        }\\n\\n        bool actorExists = Misc.addressExists(addr);\\n        if (!actorExists) {\\n            revert ActorNotFound();\\n        }\\n    }\\n\\n    /// @notice allows to interact with an non-singleton actors by its id (uint64)\\n    /// @param target actor id (uint64) to interact with\\n    /// @param method_num id of the method from the actor to call\\n    /// @param codec how the request data passed as argument is encoded\\n    /// @param raw_request encoded arguments to be passed in the call\\n    /// @param value tokens to be transfered to the called actor\\n    /// @param static_call indicates if the call will be allowed to change the actor state or not (just read the state)\\n    /// @dev it requires the id to be bigger than 99, as singleton actors are smaller than that\\n    function callNonSingletonByID(\\n        CommonTypes.FilActorId target,\\n        uint256 method_num,\\n        uint64 codec,\\n        bytes memory raw_request,\\n        uint256 value,\\n        bool static_call\\n    ) internal returns (bytes memory) {\\n        if (CommonTypes.FilActorId.unwrap(target) < 100) {\\n            revert InvalidActorID(target);\\n        }\\n\\n        return callByID(target, method_num, codec, raw_request, value, static_call);\\n    }\\n\\n    /// @notice parse the response an actor returned\\n    /// @notice it will validate the return code (success) and the codec (valid one)\\n    /// @param raw_response raw data (bytes) the actor returned\\n    /// @return the actual raw data (payload, in bytes) to be parsed according to the actor and method called\\n    function readRespData(bytes memory raw_response) internal pure returns (bytes memory) {\\n        (int256 exit, uint64 return_codec, bytes memory return_value) = abi.decode(raw_response, (int256, uint64, bytes));\\n\\n        if (return_codec == Misc.NONE_CODEC) {\\n            if (return_value.length != 0) {\\n                revert InvalidResponseLength();\\n            }\\n        } else if (return_codec == Misc.CBOR_CODEC || return_codec == Misc.DAG_CBOR_CODEC) {\\n            if (return_value.length == 0) {\\n                revert InvalidResponseLength();\\n            }\\n        } else {\\n            revert InvalidCodec(return_codec);\\n        }\\n\\n        if (exit != 0) {\\n            revert ActorError(exit);\\n        }\\n\\n        return return_value;\\n    }\\n}\\n\",\"keccak256\":\"0xa4b9eb4d84491477a3c11336a431c4f3a0796977efb92779bd062f273824c67a\",\"license\":\"Apache-2.0\"},\"@zondax/filecoin-solidity/contracts/v0.8/utils/CborDecode.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.17;\\n\\n// \\tMajUnsignedInt = 0\\n// \\tMajSignedInt   = 1\\n// \\tMajByteString  = 2\\n// \\tMajTextString  = 3\\n// \\tMajArray       = 4\\n// \\tMajMap         = 5\\n// \\tMajTag         = 6\\n// \\tMajOther       = 7\\n\\nuint8 constant MajUnsignedInt = 0;\\nuint8 constant MajSignedInt = 1;\\nuint8 constant MajByteString = 2;\\nuint8 constant MajTextString = 3;\\nuint8 constant MajArray = 4;\\nuint8 constant MajMap = 5;\\nuint8 constant MajTag = 6;\\nuint8 constant MajOther = 7;\\n\\nuint8 constant TagTypeBigNum = 2;\\nuint8 constant TagTypeNegativeBigNum = 3;\\n\\nuint8 constant True_Type = 21;\\nuint8 constant False_Type = 20;\\n\\n/// @notice This library is a set a functions that allows anyone to decode cbor encoded bytes\\n/// @dev methods in this library try to read the data type indicated from cbor encoded data stored in bytes at a specific index\\n/// @dev if it successes, methods will return the read value and the new index (intial index plus read bytes)\\n/// @author Zondax AG\\nlibrary CBORDecoder {\\n    /// @notice check if next value on the cbor encoded data is null\\n    /// @param cborData cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    function isNullNext(bytes memory cborData, uint byteIdx) internal pure returns (bool) {\\n        return cborData[byteIdx] == hex\\\"f6\\\";\\n    }\\n\\n    /// @notice attempt to read a bool value\\n    /// @param cborData cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    /// @return a bool decoded from input bytes and the byte index after moving past the value\\n    function readBool(bytes memory cborData, uint byteIdx) internal pure returns (bool, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\\n        require(maj == MajOther, \\\"invalid maj (expected MajOther)\\\");\\n        assert(value == True_Type || value == False_Type);\\n\\n        return (value != False_Type, byteIdx);\\n    }\\n\\n    /// @notice attempt to read the length of a fixed array\\n    /// @param cborData cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    /// @return length of the fixed array decoded from input bytes and the byte index after moving past the value\\n    function readFixedArray(bytes memory cborData, uint byteIdx) internal pure returns (uint, uint) {\\n        uint8 maj;\\n        uint len;\\n\\n        (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\\n        require(maj == MajArray, \\\"invalid maj (expected MajArray)\\\");\\n\\n        return (len, byteIdx);\\n    }\\n\\n    /// @notice attempt to read an arbitrary length string value\\n    /// @param cborData cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    /// @return arbitrary length string decoded from input bytes and the byte index after moving past the value\\n    function readString(bytes memory cborData, uint byteIdx) internal pure returns (string memory, uint) {\\n        uint8 maj;\\n        uint len;\\n\\n        (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\\n        require(maj == MajTextString, \\\"invalid maj (expected MajTextString)\\\");\\n\\n        uint max_len = byteIdx + len;\\n        bytes memory slice = new bytes(len);\\n        uint slice_index = 0;\\n        for (uint256 i = byteIdx; i < max_len; i++) {\\n            slice[slice_index] = cborData[i];\\n            slice_index++;\\n        }\\n\\n        return (string(slice), byteIdx + len);\\n    }\\n\\n    /// @notice attempt to read an arbitrary byte string value\\n    /// @param cborData cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    /// @return arbitrary byte string decoded from input bytes and the byte index after moving past the value\\n    function readBytes(bytes memory cborData, uint byteIdx) internal pure returns (bytes memory, uint) {\\n        uint8 maj;\\n        uint len;\\n\\n        (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\\n        require(maj == MajTag || maj == MajByteString, \\\"invalid maj (expected MajTag or MajByteString)\\\");\\n\\n        if (maj == MajTag) {\\n            (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\\n            assert(maj == MajByteString);\\n        }\\n\\n        uint max_len = byteIdx + len;\\n        bytes memory slice = new bytes(len);\\n        uint slice_index = 0;\\n        for (uint256 i = byteIdx; i < max_len; i++) {\\n            slice[slice_index] = cborData[i];\\n            slice_index++;\\n        }\\n\\n        return (slice, byteIdx + len);\\n    }\\n\\n    /// @notice attempt to read a bytes32 value\\n    /// @param cborData cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    /// @return a bytes32 decoded from input bytes and the byte index after moving past the value\\n    function readBytes32(bytes memory cborData, uint byteIdx) internal pure returns (bytes32, uint) {\\n        uint8 maj;\\n        uint len;\\n\\n        (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\\n        require(maj == MajByteString, \\\"invalid maj (expected MajByteString)\\\");\\n\\n        uint max_len = byteIdx + len;\\n        bytes memory slice = new bytes(32);\\n        uint slice_index = 32 - len;\\n        for (uint256 i = byteIdx; i < max_len; i++) {\\n            slice[slice_index] = cborData[i];\\n            slice_index++;\\n        }\\n\\n        return (bytes32(slice), byteIdx + len);\\n    }\\n\\n    /// @notice attempt to read a uint256 value encoded per cbor specification\\n    /// @param cborData cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    /// @return an uint256 decoded from input bytes and the byte index after moving past the value\\n    function readUInt256(bytes memory cborData, uint byteIdx) internal pure returns (uint256, uint) {\\n        uint8 maj;\\n        uint256 value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\\n        require(maj == MajTag || maj == MajUnsignedInt, \\\"invalid maj (expected MajTag or MajUnsignedInt)\\\");\\n\\n        if (maj == MajTag) {\\n            require(value == TagTypeBigNum, \\\"invalid tag (expected TagTypeBigNum)\\\");\\n\\n            uint len;\\n            (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\\n            require(maj == MajByteString, \\\"invalid maj (expected MajByteString)\\\");\\n\\n            require(cborData.length >= byteIdx + len, \\\"slicing out of range\\\");\\n            assembly {\\n                value := mload(add(cborData, add(len, byteIdx)))\\n            }\\n\\n            return (value, byteIdx + len);\\n        }\\n\\n        return (value, byteIdx);\\n    }\\n\\n    /// @notice attempt to read a int256 value encoded per cbor specification\\n    /// @param cborData cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    /// @return an int256 decoded from input bytes and the byte index after moving past the value\\n    function readInt256(bytes memory cborData, uint byteIdx) internal pure returns (int256, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\\n        require(maj == MajTag || maj == MajSignedInt, \\\"invalid maj (expected MajTag or MajSignedInt)\\\");\\n\\n        if (maj == MajTag) {\\n            assert(value == TagTypeNegativeBigNum);\\n\\n            uint len;\\n            (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\\n            require(maj == MajByteString, \\\"invalid maj (expected MajByteString)\\\");\\n\\n            require(cborData.length >= byteIdx + len, \\\"slicing out of range\\\");\\n            assembly {\\n                value := mload(add(cborData, add(len, byteIdx)))\\n            }\\n\\n            return (int256(value), byteIdx + len);\\n        }\\n\\n        return (int256(value), byteIdx);\\n    }\\n\\n    /// @notice attempt to read a uint64 value\\n    /// @param cborData cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    /// @return an uint64 decoded from input bytes and the byte index after moving past the value\\n    function readUInt64(bytes memory cborData, uint byteIdx) internal pure returns (uint64, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\\n        require(maj == MajUnsignedInt, \\\"invalid maj (expected MajUnsignedInt)\\\");\\n\\n        return (uint64(value), byteIdx);\\n    }\\n\\n    /// @notice attempt to read a uint32 value\\n    /// @param cborData cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    /// @return an uint32 decoded from input bytes and the byte index after moving past the value\\n    function readUInt32(bytes memory cborData, uint byteIdx) internal pure returns (uint32, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\\n        require(maj == MajUnsignedInt, \\\"invalid maj (expected MajUnsignedInt)\\\");\\n\\n        return (uint32(value), byteIdx);\\n    }\\n\\n    /// @notice attempt to read a uint16 value\\n    /// @param cborData cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    /// @return an uint16 decoded from input bytes and the byte index after moving past the value\\n    function readUInt16(bytes memory cborData, uint byteIdx) internal pure returns (uint16, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\\n        require(maj == MajUnsignedInt, \\\"invalid maj (expected MajUnsignedInt)\\\");\\n\\n        return (uint16(value), byteIdx);\\n    }\\n\\n    /// @notice attempt to read a uint8 value\\n    /// @param cborData cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    /// @return an uint8 decoded from input bytes and the byte index after moving past the value\\n    function readUInt8(bytes memory cborData, uint byteIdx) internal pure returns (uint8, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\\n        require(maj == MajUnsignedInt, \\\"invalid maj (expected MajUnsignedInt)\\\");\\n\\n        return (uint8(value), byteIdx);\\n    }\\n\\n    /// @notice attempt to read a int64 value\\n    /// @param cborData cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    /// @return an int64 decoded from input bytes and the byte index after moving past the value\\n    function readInt64(bytes memory cborData, uint byteIdx) internal pure returns (int64, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\\n        require(maj == MajSignedInt || maj == MajUnsignedInt, \\\"invalid maj (expected MajSignedInt or MajUnsignedInt)\\\");\\n\\n        return (int64(uint64(value)), byteIdx);\\n    }\\n\\n    /// @notice attempt to read a int32 value\\n    /// @param cborData cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    /// @return an int32 decoded from input bytes and the byte index after moving past the value\\n    function readInt32(bytes memory cborData, uint byteIdx) internal pure returns (int32, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\\n        require(maj == MajSignedInt || maj == MajUnsignedInt, \\\"invalid maj (expected MajSignedInt or MajUnsignedInt)\\\");\\n\\n        return (int32(uint32(value)), byteIdx);\\n    }\\n\\n    /// @notice attempt to read a int16 value\\n    /// @param cborData cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    /// @return an int16 decoded from input bytes and the byte index after moving past the value\\n    function readInt16(bytes memory cborData, uint byteIdx) internal pure returns (int16, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\\n        require(maj == MajSignedInt || maj == MajUnsignedInt, \\\"invalid maj (expected MajSignedInt or MajUnsignedInt)\\\");\\n\\n        return (int16(uint16(value)), byteIdx);\\n    }\\n\\n    /// @notice attempt to read a int8 value\\n    /// @param cborData cbor encoded bytes to parse from\\n    /// @param byteIdx current position to read on the cbor encoded bytes\\n    /// @return an int8 decoded from input bytes and the byte index after moving past the value\\n    function readInt8(bytes memory cborData, uint byteIdx) internal pure returns (int8, uint) {\\n        uint8 maj;\\n        uint value;\\n\\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\\n        require(maj == MajSignedInt || maj == MajUnsignedInt, \\\"invalid maj (expected MajSignedInt or MajUnsignedInt)\\\");\\n\\n        return (int8(uint8(value)), byteIdx);\\n    }\\n\\n    /// @notice slice uint8 from bytes starting at a given index\\n    /// @param bs bytes to slice from\\n    /// @param start current position to slice from bytes\\n    /// @return uint8 sliced from bytes\\n    function sliceUInt8(bytes memory bs, uint start) internal pure returns (uint8) {\\n        require(bs.length >= start + 1, \\\"slicing out of range\\\");\\n        return uint8(bs[start]);\\n    }\\n\\n    /// @notice slice uint16 from bytes starting at a given index\\n    /// @param bs bytes to slice from\\n    /// @param start current position to slice from bytes\\n    /// @return uint16 sliced from bytes\\n    function sliceUInt16(bytes memory bs, uint start) internal pure returns (uint16) {\\n        require(bs.length >= start + 2, \\\"slicing out of range\\\");\\n        bytes2 x;\\n        assembly {\\n            x := mload(add(bs, add(0x20, start)))\\n        }\\n        return uint16(x);\\n    }\\n\\n    /// @notice slice uint32 from bytes starting at a given index\\n    /// @param bs bytes to slice from\\n    /// @param start current position to slice from bytes\\n    /// @return uint32 sliced from bytes\\n    function sliceUInt32(bytes memory bs, uint start) internal pure returns (uint32) {\\n        require(bs.length >= start + 4, \\\"slicing out of range\\\");\\n        bytes4 x;\\n        assembly {\\n            x := mload(add(bs, add(0x20, start)))\\n        }\\n        return uint32(x);\\n    }\\n\\n    /// @notice slice uint64 from bytes starting at a given index\\n    /// @param bs bytes to slice from\\n    /// @param start current position to slice from bytes\\n    /// @return uint64 sliced from bytes\\n    function sliceUInt64(bytes memory bs, uint start) internal pure returns (uint64) {\\n        require(bs.length >= start + 8, \\\"slicing out of range\\\");\\n        bytes8 x;\\n        assembly {\\n            x := mload(add(bs, add(0x20, start)))\\n        }\\n        return uint64(x);\\n    }\\n\\n    /// @notice Parse cbor header for major type and extra info.\\n    /// @param cbor cbor encoded bytes to parse from\\n    /// @param byteIndex current position to read on the cbor encoded bytes\\n    /// @return major type, extra info and the byte index after moving past header bytes\\n    function parseCborHeader(bytes memory cbor, uint byteIndex) internal pure returns (uint8, uint64, uint) {\\n        uint8 first = sliceUInt8(cbor, byteIndex);\\n        byteIndex += 1;\\n        uint8 maj = (first & 0xe0) >> 5;\\n        uint8 low = first & 0x1f;\\n        // We don't handle CBOR headers with extra > 27, i.e. no indefinite lengths\\n        require(low < 28, \\\"cannot handle headers with extra > 27\\\");\\n\\n        // extra is lower bits\\n        if (low < 24) {\\n            return (maj, low, byteIndex);\\n        }\\n\\n        // extra in next byte\\n        if (low == 24) {\\n            uint8 next = sliceUInt8(cbor, byteIndex);\\n            byteIndex += 1;\\n            require(next >= 24, \\\"invalid cbor\\\"); // otherwise this is invalid cbor\\n            return (maj, next, byteIndex);\\n        }\\n\\n        // extra in next 2 bytes\\n        if (low == 25) {\\n            uint16 extra16 = sliceUInt16(cbor, byteIndex);\\n            byteIndex += 2;\\n            return (maj, extra16, byteIndex);\\n        }\\n\\n        // extra in next 4 bytes\\n        if (low == 26) {\\n            uint32 extra32 = sliceUInt32(cbor, byteIndex);\\n            byteIndex += 4;\\n            return (maj, extra32, byteIndex);\\n        }\\n\\n        // extra in next 8 bytes\\n        assert(low == 27);\\n        uint64 extra64 = sliceUInt64(cbor, byteIndex);\\n        byteIndex += 8;\\n        return (maj, extra64, byteIndex);\\n    }\\n}\\n\",\"keccak256\":\"0x3babe3c71558c21f0bef9de09088c42b8b148d16d856f84a350b9c43b4da6018\",\"license\":\"Apache-2.0\"},\"@zondax/filecoin-solidity/contracts/v0.8/utils/FilAddresses.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.17;\\n\\nimport \\\"../types/CommonTypes.sol\\\";\\nimport \\\"../utils/Leb128.sol\\\";\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\n\\n/// @notice This library is a set a functions that allows to handle filecoin addresses conversions and validations\\n/// @author Zondax AG\\nlibrary FilAddresses {\\n    using Buffer for Buffer.buffer;\\n\\n    error InvalidAddress();\\n\\n    /// @notice allow to get a FilAddress from an eth address\\n    /// @param addr eth address to convert\\n    /// @return new filecoin address\\n    function fromEthAddress(address addr) internal pure returns (CommonTypes.FilAddress memory) {\\n        return CommonTypes.FilAddress(abi.encodePacked(hex\\\"040a\\\", addr));\\n    }\\n\\n    /// @notice allow to create a Filecoin address from an actorID\\n    /// @param actorID uint64 actorID\\n    /// @return address filecoin address\\n    function fromActorID(uint64 actorID) internal pure returns (CommonTypes.FilAddress memory) {\\n        Buffer.buffer memory result = Leb128.encodeUnsignedLeb128FromUInt64(actorID);\\n        return CommonTypes.FilAddress(abi.encodePacked(hex\\\"00\\\", result.buf));\\n    }\\n\\n    /// @notice allow to create a Filecoin address from bytes\\n    /// @param data address in bytes format\\n    /// @return filecoin address\\n    function fromBytes(bytes memory data) internal pure returns (CommonTypes.FilAddress memory) {\\n        CommonTypes.FilAddress memory newAddr = CommonTypes.FilAddress(data);\\n        if (!validate(newAddr)) {\\n            revert InvalidAddress();\\n        }\\n\\n        return newAddr;\\n    }\\n\\n    /// @notice allow to validate if an address is valid or not\\n    /// @dev we are only validating known address types. If the type is not known, the default value is true\\n    /// @param addr the filecoin address to validate\\n    /// @return whether the address is valid or not\\n    function validate(CommonTypes.FilAddress memory addr) internal pure returns (bool) {\\n        if (addr.data[0] == 0x00) {\\n            return addr.data.length <= 10;\\n        } else if (addr.data[0] == 0x01 || addr.data[0] == 0x02) {\\n            return addr.data.length == 21;\\n        } else if (addr.data[0] == 0x03) {\\n            return addr.data.length == 49;\\n        } else if (addr.data[0] == 0x04) {\\n            return addr.data.length <= 64;\\n        }\\n\\n        return addr.data.length <= 256;\\n    }\\n}\\n\",\"keccak256\":\"0x3ca8652660af7a3ff1b894b7c8a875645999b561499e960198dfe330d39ce387\",\"license\":\"Apache-2.0\"},\"@zondax/filecoin-solidity/contracts/v0.8/utils/Leb128.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2023 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.17;\\n\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\n\\n/// @notice This library implement the leb128\\n/// @author Zondax AG\\nlibrary Leb128 {\\n    using Buffer for Buffer.buffer;\\n\\n    /// @notice encode a unsigned integer 64bits into bytes\\n    /// @param value the actor ID to encode\\n    /// @return result return the value in bytes\\n    function encodeUnsignedLeb128FromUInt64(uint64 value) internal pure returns (Buffer.buffer memory result) {\\n        while (true) {\\n            uint64 byte_ = value & 0x7f;\\n            value >>= 7;\\n            if (value == 0) {\\n                result.appendUint8(uint8(byte_));\\n                return result;\\n            }\\n            result.appendUint8(uint8(byte_ | 0x80));\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe1f4d71cdc933b0c2ac8eb81d711bf63457ed8e79b748ca9f826d40a3b4f143b\",\"license\":\"Apache-2.0\"},\"@zondax/filecoin-solidity/contracts/v0.8/utils/Misc.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.17;\\n\\nimport \\\"../types/CommonTypes.sol\\\";\\n\\n/// @title Library containing miscellaneous functions used on the project\\n/// @author Zondax AG\\nlibrary Misc {\\n    uint64 constant DAG_CBOR_CODEC = 0x71;\\n    uint64 constant CBOR_CODEC = 0x51;\\n    uint64 constant NONE_CODEC = 0x00;\\n\\n    // Code taken from Openzeppelin repo\\n    // Link: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/0320a718e8e07b1d932f5acb8ad9cec9d9eed99b/contracts/utils/math/SignedMath.sol#L37-L42\\n    /// @notice get the abs from a signed number\\n    /// @param n number to get abs from\\n    /// @return unsigned number\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n\\n    /// @notice validate if an address exists or not\\n    /// @dev read this article for more information https://blog.finxter.com/how-to-find-out-if-an-ethereum-address-is-a-contract/\\n    /// @param addr address to check\\n    /// @return whether the address exists or not\\n    function addressExists(address addr) internal view returns (bool) {\\n        bytes32 codehash;\\n        assembly {\\n            codehash := extcodehash(addr)\\n        }\\n        return codehash != 0x0;\\n    }\\n\\n    /// Returns the data size required by CBOR.writeFixedNumeric\\n    function getPrefixSize(uint256 data_size) internal pure returns (uint256) {\\n        if (data_size <= 23) {\\n            return 1;\\n        } else if (data_size <= 0xFF) {\\n            return 2;\\n        } else if (data_size <= 0xFFFF) {\\n            return 3;\\n        } else if (data_size <= 0xFFFFFFFF) {\\n            return 5;\\n        }\\n        return 9;\\n    }\\n\\n    function getBytesSize(bytes memory value) internal pure returns (uint256) {\\n        return getPrefixSize(value.length) + value.length;\\n    }\\n\\n    function getCidSize(bytes memory value) internal pure returns (uint256) {\\n        return getPrefixSize(2) + value.length;\\n    }\\n\\n    function getFilActorIdSize(CommonTypes.FilActorId value) internal pure returns (uint256) {\\n        uint64 val = CommonTypes.FilActorId.unwrap(value);\\n        return getPrefixSize(uint256(val));\\n    }\\n\\n    function getChainEpochSize(CommonTypes.ChainEpoch value) internal pure returns (uint256) {\\n        int64 val = CommonTypes.ChainEpoch.unwrap(value);\\n        if (val >= 0) {\\n            return getPrefixSize(uint256(uint64(val)));\\n        } else {\\n            return getPrefixSize(uint256(uint64(-1 - val)));\\n        }\\n    }\\n\\n    function getBoolSize() internal pure returns (uint256) {\\n        return getPrefixSize(1);\\n    }\\n}\\n\",\"keccak256\":\"0x97b02c3ab9cb11169b0b1a143b513017c6bf0f2cba2fc4f81a77345b5dfe96b4\",\"license\":\"Apache-2.0\"},\"contracts/retrieve/appeals/Appeals.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\r\\nimport \\\"./../settings/Settings.sol\\\";\\r\\nimport \\\"./../deals/Deals.sol\\\";\\r\\nimport \\\"./../vault/Vault.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Appeals\\r\\n */\\r\\ncontract Appeals is Ownable, ReentrancyGuard {\\r\\n    using Counters for Counters.Counter;\\r\\n\\r\\n    // Defining provider struct\\r\\n    // TODO: Repace with new entry\\r\\n    struct Referee {\\r\\n        bool active;\\r\\n        string endpoint;\\r\\n    }\\r\\n\\r\\n    // Defining appeal struct\\r\\n    // TODO: Replace with new deal\\r\\n    struct Appeal {\\r\\n        // Index object of the deal\\r\\n        uint256 deal_index;\\r\\n        // Describe if appeal is active or not\\r\\n        bool active;\\r\\n        // Mapping that stores what rounds were processed\\r\\n        mapping(uint256 => bool) processed;\\r\\n        // Counter for slashes\\r\\n        uint128 slashes;\\r\\n        // Block timestamp of deal creation\\r\\n        uint256 request_timestamp;\\r\\n        // Adding block timestamp to calculate timeout\\r\\n        uint256 origin_timestamp;\\r\\n    }\\r\\n    Settings settings;\\r\\n    Deals dealsStore;\\r\\n    Vault vaultStore;\\r\\n\\r\\n    mapping(address => Referee) public referees;\\r\\n    // Array of active referees\\r\\n    address[] public active_referees;\\r\\n    // Mapping appeals\\r\\n    mapping(uint256 => Appeal) public appeals;\\r\\n    // Mapping all appeals using deal_index as index\\r\\n    mapping(uint256 => uint8) public tot_appeals;\\r\\n    // Mapping pending appeals using data_uri as index\\r\\n    mapping(uint256 => uint256) public pending_appeals;\\r\\n    // Mapping active appeals using deal_index as index\\r\\n    mapping(uint256 => uint256) public active_appeals;\\r\\n\\r\\n    // Event emitted when new appeal is created\\r\\n    event AppealCreated(uint256 index, address provider, uint256 deal_index);\\r\\n    // Event emitted when new appeal started\\r\\n    event AppealStarted(uint256 index);\\r\\n    // Event emitted when a slash message is recorded\\r\\n    event RoundSlashed(uint256 index);\\r\\n    // Event emitted when a deal is invalidated by an appeal\\r\\n    event DealInvalidated(uint256 index);\\r\\n\\r\\n    Counters.Counter private appealCounter;\\r\\n\\r\\n    constructor(address _settings_address, address _vault_address) {\\r\\n        settings = Settings(_settings_address);\\r\\n        vaultStore = Vault(_vault_address);\\r\\n    }\\r\\n\\r\\n    function setDealsAddress(address _deals_address) external onlyOwner {\\r\\n        dealsStore = Deals(_deals_address);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method will allow client to create an appeal\\r\\n    */\\r\\n    function createAppeal(uint256 deal_index) external nonReentrant {\\r\\n        require(\\r\\n            tot_appeals[deal_index] < settings.max_appeals(),\\r\\n            \\\"Can't create more appeals on deal\\\"\\r\\n        );\\r\\n        require(dealsStore.isActive(deal_index), \\\"Deal is not active\\\");\\r\\n        require(dealsStore.dealNotEnded(deal_index), \\\"Deal ended, can't create appeals\\\");\\r\\n        // Check if appeal address was listed\\r\\n        require(\\r\\n            dealsStore.isOwner(deal_index, msg.sender),\\r\\n            \\\"Only authorized addresses can create appeal\\\"\\r\\n        );\\r\\n        // Check if there's a pending appeal request\\r\\n        require(pending_appeals[deal_index] == 0, \\\"There's a pending appeal request\\\");\\r\\n        // Check if appeal exists or is expired\\r\\n        require(\\r\\n            active_appeals[deal_index] == 0 ||\\r\\n                // Check if appeal is expired\\r\\n                getRound(active_appeals[deal_index]) >= 99,\\r\\n            \\\"Appeal exists yet for provided hash\\\"\\r\\n        );\\r\\n        // Be sure sent amount is exactly the appeal fee\\r\\n        require(\\r\\n            vaultStore.getBalance(msg.sender) >= returnAppealFee(deal_index),\\r\\n            // msg.value == returnAppealFee(deal_index),\\r\\n            \\\"Must have enough balance in vault to create an appeal\\\"\\r\\n        );\\r\\n\\r\\n        vaultStore.sub(msg.sender, returnAppealFee(deal_index));\\r\\n\\r\\n        // Split fee to referees\\r\\n        uint256 payment = returnAppealFee(deal_index);\\r\\n        tot_appeals[deal_index]++;\\r\\n        if (payment > 0) {\\r\\n            uint256 fee = payment / active_referees.length;\\r\\n            for (uint256 i = 0; i < active_referees.length; i++) {\\r\\n                vaultStore.add(active_referees[i], fee);\\r\\n            }\\r\\n        }\\r\\n        // Creating next id\\r\\n        appealCounter.increment();\\r\\n        uint256 index = appealCounter.current();\\r\\n        // Storing appeal status\\r\\n        pending_appeals[deal_index] = index;\\r\\n        // Creating appeal\\r\\n        appeals[index].deal_index = deal_index;\\r\\n        appeals[index].active = true;\\r\\n        appeals[index].request_timestamp = block.timestamp;\\r\\n        // Emit appeal created event\\r\\n        emit AppealCreated(index, dealsStore.getOwner(deal_index), deal_index);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method will allow referees to start an appeal\\r\\n    */\\r\\n    function startAppeal(uint256 appeal_index) external {\\r\\n        require(appeals[appeal_index].origin_timestamp == 0, \\\"Appeal started yet\\\");\\r\\n        require(referees[msg.sender].active, \\\"Only referees can start appeals\\\");\\r\\n        appeals[appeal_index].origin_timestamp = block.timestamp;\\r\\n        // Reset pending appeal state\\r\\n        pending_appeals[appeals[appeal_index].deal_index] = 0;\\r\\n        // Set active appeal state\\r\\n        active_appeals[appeals[appeal_index].deal_index] = appeal_index;\\r\\n        // Emit appeal created event\\r\\n        emit AppealStarted(appeal_index);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method checks for duplicate signatures\\r\\n    */\\r\\n    function checkDuplicate(bytes[] memory _arr) internal pure returns (bool) {\\r\\n        if (_arr.length == 0) {\\r\\n            return false;\\r\\n        }\\r\\n        for (uint256 i = 0; i < _arr.length - 1; i++) {\\r\\n            for (uint256 j = i + 1; j < _arr.length; j++) {\\r\\n                if (sha256(_arr[i]) == sha256(_arr[j])) {\\r\\n                    return true;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method will allow referees to process an appeal\\r\\n    */\\r\\n    function processAppeal(\\r\\n        uint256 deal_index,\\r\\n        address[] memory _referees,\\r\\n        bytes[] memory _signatures\\r\\n    ) external {\\r\\n        uint256 appeal_index = active_appeals[deal_index];\\r\\n        uint256 round = getRound(appeal_index);\\r\\n        // KS-PLW-01: Duplicate Signatures are not checked while processing an appeal\\r\\n        require(!checkDuplicate(_signatures), \\\"processAppeal: Duplicate signatures\\\");\\r\\n        require(dealsStore.isActive(deal_index), \\\"Deal is not active\\\");\\r\\n        require(appeals[appeal_index].active, \\\"Appeal is not active\\\");\\r\\n        require(referees[msg.sender].active, \\\"Only referees can process appeals\\\");\\r\\n        require(round <= settings.rounds_limit(), \\\"This appeal can't be processed anymore\\\");\\r\\n        require(!appeals[appeal_index].processed[round], \\\"This round was processed yet\\\");\\r\\n        appeals[appeal_index].processed[round] = true;\\r\\n        bool slashed = false;\\r\\n        if (getElectedLeader(appeal_index) == msg.sender) {\\r\\n            appeals[appeal_index].slashes++;\\r\\n            slashed = true;\\r\\n        } else {\\r\\n            for (uint256 i = 0; i < _referees.length; i++) {\\r\\n                address referee = _referees[i];\\r\\n                bytes memory signature = _signatures[i];\\r\\n                // Be sure leader is not hacking the system\\r\\n                require(\\r\\n                    verifyRefereeSignature(signature, deal_index, referee),\\r\\n                    \\\"Signature doesn't matches\\\"\\r\\n                );\\r\\n            }\\r\\n            if ((_signatures.length * 100) > refereeConsensusThreshold()) {\\r\\n                appeals[appeal_index].slashes++;\\r\\n                slashed = true;\\r\\n            }\\r\\n        }\\r\\n        require(slashed, \\\"Appeal wasn't slashed, not the leader or no consensus\\\");\\r\\n        emit RoundSlashed(appeal_index);\\r\\n        if (appeals[appeal_index].slashes >= settings.slashes_threshold()) {\\r\\n            dealsStore.retireDeal(deal_index);\\r\\n            appeals[appeal_index].active = false;\\r\\n            // Return value of deal back to owner\\r\\n            vaultStore.subFromVault(dealsStore.getValue(deal_index));\\r\\n            vaultStore.add(dealsStore.getOwner(deal_index), dealsStore.getValue(deal_index));\\r\\n            // Remove funds from provider and charge provider\\r\\n            uint256 collateral = dealsStore.getCollateral(deal_index);\\r\\n            vaultStore.subFromVault(collateral);\\r\\n            // All collateral to protocol's address:\\r\\n            vaultStore.addToProtocol(collateral);\\r\\n            // Split collateral between client and protocol:\\r\\n            // -> vault[settings.protocol_address()] += collateral / 2;\\r\\n            // -> vault[deals[deal_index].owner] += collateral / 2;\\r\\n            emit DealInvalidated(deal_index);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method will return the amount in ETH needed to create an appeal\\r\\n    */\\r\\n    function returnAppealFee(uint256 deal_index) public view returns (uint256) {\\r\\n        uint256 fee = dealsStore.getValue(deal_index) / settings.committee_divider();\\r\\n        return fee;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method verifies a signature\\r\\n    */\\r\\n    function verifyRefereeSignature(\\r\\n        bytes memory _signature,\\r\\n        uint256 deal_index,\\r\\n        address referee\\r\\n    ) public view returns (bool) {\\r\\n        require(referees[referee].active, \\\"Provided address is not a referee\\\");\\r\\n        bytes memory message = getPrefix(deal_index);\\r\\n        bytes32 hashed = ECDSA.toEthSignedMessageHash(message);\\r\\n        address recovered = ECDSA.recover(hashed, _signature);\\r\\n        return recovered == referee;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method returns the prefix for\\r\\n    */\\r\\n    function getPrefix(uint256 appeal_index) public view returns (bytes memory) {\\r\\n        uint256 deal_index = appeals[appeal_index].deal_index;\\r\\n        uint256 round = getRound(appeal_index);\\r\\n        return\\r\\n            abi.encodePacked(\\r\\n                Strings.toString(deal_index),\\r\\n                Strings.toString(appeal_index),\\r\\n                Strings.toString(round)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method will say if address is a referee or not\\r\\n    */\\r\\n    function isReferee(address check) public view returns (bool) {\\r\\n        return referees[check].active;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method safely removes an active referee from it's corresponding array,\\r\\n        part of KS-PLW-06: Removal of referee adds null address to array index\\r\\n    */\\r\\n    function removeActiveReferee(uint _index) private {\\r\\n        require(_index < active_referees.length, \\\"index out of bound\\\");\\r\\n\\r\\n        for (uint i = _index; i < active_referees.length - 1; i++) {\\r\\n            active_referees[i] = active_referees[i + 1];\\r\\n        }\\r\\n        active_referees.pop();\\r\\n    }\\r\\n\\r\\n    function emulateReferee(string memory _endpoint) external {\\r\\n        require(!isReferee(msg.sender), \\\"Duplicate referees are not permitted\\\");\\r\\n        referees[msg.sender].active = true;\\r\\n        referees[msg.sender].endpoint = _endpoint;\\r\\n        active_referees.push(msg.sender);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method will allow owner to enable or disable a referee\\r\\n    */\\r\\n    function setRefereeStatus(\\r\\n        address _referee,\\r\\n        bool _state,\\r\\n        string memory _endpoint\\r\\n    ) external onlyOwner {\\r\\n        if (_state) {\\r\\n            // KS-PLW-05: Duplicate referee address is allowed\\r\\n            require(!isReferee(_referee), \\\"Duplicate referees are not permitted\\\");\\r\\n            referees[_referee].active = _state;\\r\\n            referees[_referee].endpoint = _endpoint;\\r\\n            active_referees.push(_referee);\\r\\n        } else {\\r\\n            for (uint256 i = 0; i < active_referees.length; i++) {\\r\\n                if (active_referees[i] == _referee) {\\r\\n                    // KS-PLW-06: Removal of referee adds null address to array index\\r\\n                    removeActiveReferee(i);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method will return the amount of signatures needed to close a rount\\r\\n    */\\r\\n    function refereeConsensusThreshold() public view returns (uint256) {\\r\\n        uint256 half = (active_referees.length * 100) / 2;\\r\\n        return half;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method will return the leader for a provided appeal\\r\\n    */\\r\\n    function getElectedLeader(uint256 appeal_index) public view returns (address) {\\r\\n        uint256 round = getRound(appeal_index);\\r\\n        uint256 seed = uint256(\\r\\n            keccak256(\\r\\n                abi.encodePacked(appeals[appeal_index].origin_timestamp + appeal_index + round)\\r\\n            )\\r\\n        );\\r\\n        uint256 leader = (seed - ((seed / active_referees.length) * active_referees.length));\\r\\n        return active_referees[leader];\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method will return the round for provided appeal\\r\\n    */\\r\\n    function getRound(uint256 appeal_index) public view returns (uint256) {\\r\\n        uint256 appeal_duration = settings.round_duration() * settings.rounds_limit();\\r\\n        uint256 appeal_end = appeals[appeal_index].origin_timestamp + appeal_duration;\\r\\n        if (appeal_end >= block.timestamp) {\\r\\n            uint256 remaining_time = appeal_end - block.timestamp;\\r\\n            uint256 remaining_rounds = remaining_time / settings.round_duration();\\r\\n            uint256 round = settings.rounds_limit() - remaining_rounds;\\r\\n            return round;\\r\\n        } else {\\r\\n            // Means appeal is ended\\r\\n            return 99;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method will return appeal address status in deal\\r\\n    */\\r\\n    function canAddressAppeal(\\r\\n        uint256 deal_index,\\r\\n        address appeal_address\\r\\n    ) external view returns (bool) {\\r\\n        return dealsStore.isReferee(deal_index, appeal_address);\\r\\n    }\\r\\n\\r\\n    function totalAppeals() external view returns (uint256) {\\r\\n        return appealCounter.current();\\r\\n    }\\r\\n\\r\\n    function hasNoActiveAppeals(uint256 deal_index) external view returns (bool) {\\r\\n        return active_appeals[deal_index] >= 99;\\r\\n    }\\r\\n\\r\\n    function hasNoPendingAppeals(uint256 deal_index) external view returns (bool) {\\r\\n        return pending_appeals[deal_index] == 0;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x4996d64445196cbe00fbc04e5e5157af1c1f2bf7cea83372fa06932f2e0d24bd\",\"license\":\"MIT\"},\"contracts/retrieve/deals/Deals.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\r\\nimport {MarketAPI} from \\\"@zondax/filecoin-solidity/contracts/v0.8/MarketAPI.sol\\\";\\r\\nimport {MarketTypes} from \\\"@zondax/filecoin-solidity/contracts/v0.8/types/MarketTypes.sol\\\";\\r\\nimport {CommonTypes} from \\\"@zondax/filecoin-solidity/contracts/v0.8/types/CommonTypes.sol\\\";\\r\\nimport \\\"./../libs/ERC721.sol\\\";\\r\\nimport \\\"./../settings/Settings.sol\\\";\\r\\nimport \\\"./../appeals/Appeals.sol\\\";\\r\\nimport \\\"./../vault/Vault.sol\\\";\\r\\nimport \\\"./../providers/Providers.sol\\\";\\r\\n\\r\\ncontract Deals is ERC721, Ownable, ReentrancyGuard {\\r\\n    using Counters for Counters.Counter;\\r\\n    // Defining deal struct\\r\\n    enum Status {\\r\\n        None,\\r\\n        RequestSubmitted,\\r\\n        DealPublished,\\r\\n        DealActivated,\\r\\n        DealTerminated,\\r\\n        DealRedeemed\\r\\n    }\\r\\n\\r\\n    struct RetrievalDeal {\\r\\n        address owner;\\r\\n        uint64 deal_id;\\r\\n        uint256 retrieval_provider_collateral;\\r\\n        uint256 retrieval_value;\\r\\n        bool canceled;\\r\\n        Status status;\\r\\n        uint256 timestamp_request;\\r\\n        uint256 timestamp_start;\\r\\n        mapping(address => bool) appeal_addresses;\\r\\n        MarketTypes.GetDealTermReturn term;\\r\\n        MarketTypes.GetDealDataCommitmentReturn dealCommitment;\\r\\n        uint64 provider_actor_id;\\r\\n        uint64 client_actor_id;\\r\\n    }\\r\\n\\r\\n    struct RetrievalDealReturn {\\r\\n        uint256 id;\\r\\n        address owner;\\r\\n        uint64 deal_id;\\r\\n        uint256 retrieval_provider_collateral;\\r\\n        uint256 retrieval_value;\\r\\n        bool canceled;\\r\\n        Status status;\\r\\n        uint256 timestamp_request;\\r\\n        uint256 timestamp_start;\\r\\n        uint64 provider_actor_id;\\r\\n        uint64 client_actor_id;\\r\\n        int64 deal_start;\\r\\n        int64 deal_end;\\r\\n        bytes data;\\r\\n        uint64 size;\\r\\n        bytes appeal_addresses;\\r\\n    }\\r\\n\\r\\n    mapping(uint256 => RetrievalDeal) public retrieval_deals;\\r\\n\\r\\n    mapping(uint256 => address[]) public retrieval_deal_appeal_addresses;\\r\\n\\r\\n    Counters.Counter private dealCounter;\\r\\n\\r\\n    Settings public settings;\\r\\n\\r\\n    Appeals public appeals;\\r\\n\\r\\n    Vault public vaultStore;\\r\\n\\r\\n    Providers public providersStore;\\r\\n\\r\\n    event RetrievalDealProposalCreate(\\r\\n        uint256 index,\\r\\n        address owner,\\r\\n        uint64 deal_id,\\r\\n        uint256 retrieval_provider_collateral,\\r\\n        uint256 retrieval_value,\\r\\n        address[] appeal_addresses\\r\\n    );\\r\\n\\r\\n    event DealProposalCanceled(uint256 index);\\r\\n\\r\\n    constructor(\\r\\n        address _settings_address,\\r\\n        address _vault_address,\\r\\n        address _appeals_address,\\r\\n        address _providers_address\\r\\n    ) ERC721(\\\"Retrieve Deals\\\", \\\"RTRV\\\") {\\r\\n        settings = Settings(_settings_address);\\r\\n        vaultStore = Vault(_vault_address);\\r\\n        appeals = Appeals(_appeals_address);\\r\\n        providersStore = Providers(_providers_address);\\r\\n    }\\r\\n\\r\\n    function isActive(uint256 _deal_index) public view returns (bool) {\\r\\n        return retrieval_deals[_deal_index].timestamp_start > 0;\\r\\n    }\\r\\n\\r\\n    function retireDeal(uint256 _deal_index) public {\\r\\n        // TODO: Only appeals address can make this change and provider contract address\\r\\n        retrieval_deals[_deal_index].timestamp_start = 0;\\r\\n        retrieval_deals[_deal_index].status = Status.DealRedeemed;\\r\\n    }\\r\\n\\r\\n    function startDeal(uint256 _deal_index) public {\\r\\n        // TODO: Only providers contract should be able to use this\\r\\n        require(\\r\\n            retrieval_deals[_deal_index].status == Status.RequestSubmitted,\\r\\n            \\\"Deal not in published state\\\"\\r\\n        );\\r\\n        retrieval_deals[_deal_index].timestamp_start = block.timestamp;\\r\\n        retrieval_deals[_deal_index].status = Status.DealActivated;\\r\\n    }\\r\\n\\r\\n    function dealNotEnded(uint256 _deal_index) public view returns (bool) {\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function isReferee(uint256 _deal_index, address _address) public view returns (bool) {\\r\\n        return retrieval_deals[_deal_index].appeal_addresses[_address];\\r\\n    }\\r\\n\\r\\n    function isOwner(uint256 _deal_index, address _address) public view returns (bool) {\\r\\n        return retrieval_deals[_deal_index].owner == _address;\\r\\n    }\\r\\n\\r\\n    function getDataUri(uint256 _deal_index) public view returns (string memory) {\\r\\n        return string(retrieval_deals[_deal_index].dealCommitment.data);\\r\\n    }\\r\\n\\r\\n    function getValue(uint256 _deal_index) public view returns (uint256) {\\r\\n        return retrieval_deals[_deal_index].retrieval_value;\\r\\n    }\\r\\n\\r\\n    function getCollateral(uint256 _deal_index) public view returns (uint256) {\\r\\n        return retrieval_deals[_deal_index].retrieval_provider_collateral;\\r\\n    }\\r\\n\\r\\n    function isCancelled(uint256 _deal_index) public view returns (bool) {\\r\\n        return retrieval_deals[_deal_index].canceled;\\r\\n    }\\r\\n\\r\\n    function isProvider(uint256 _deal_index, address _provider) public view returns (bool) {\\r\\n        return\\r\\n            providersStore.getAddress(retrieval_deals[_deal_index].provider_actor_id) == _provider;\\r\\n    }\\r\\n\\r\\n    function getTimestampRequest(uint256 _deal_index) public view returns (uint256) {\\r\\n        return retrieval_deals[_deal_index].timestamp_request;\\r\\n    }\\r\\n\\r\\n    // TODO: only provider contract should be able to call this function\\r\\n    function mint(address _address, uint256 _deal_index) public {\\r\\n        _mint(_address, _deal_index);\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return dealCounter.current();\\r\\n    }\\r\\n\\r\\n    function totalDeals() external view returns (uint256) {\\r\\n        return dealCounter.current();\\r\\n    }\\r\\n\\r\\n    function balanceOf(address _to_check) public view virtual override returns (uint256) {\\r\\n        uint256 totalTkns = totalSupply();\\r\\n        uint256 resultIndex = 0;\\r\\n        uint256 tnkId;\\r\\n\\r\\n        for (tnkId = 1; tnkId <= totalTkns; tnkId++) {\\r\\n            if (ownerOf(tnkId) == _to_check) {\\r\\n                resultIndex++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return resultIndex;\\r\\n    }\\r\\n\\r\\n    function getOwner(uint256 _deal_index) public view returns (address) {\\r\\n        if (retrieval_deals[_deal_index].owner != address(0)) {\\r\\n            return retrieval_deals[_deal_index].owner;\\r\\n        } else {\\r\\n            return ownerOf(_deal_index);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getStartTimestamp(uint256 _deal_index) public view returns (uint256) {\\r\\n        return retrieval_deals[_deal_index].timestamp_start;\\r\\n    }\\r\\n\\r\\n    function getDuration(uint256 _deal_index) public view returns (uint256) {\\r\\n        MarketTypes.GetDealTermReturn memory term;\\r\\n        term = retrieval_deals[_deal_index].term;\\r\\n        return\\r\\n            uint256(\\r\\n                uint64(\\r\\n                    CommonTypes.ChainEpoch.unwrap(term.end) -\\r\\n                        CommonTypes.ChainEpoch.unwrap(term.start)\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\r\\n        RetrievalDeal storage retrieval_deal = retrieval_deals[tokenId];\\r\\n        string memory output = settings.token_render().render(\\r\\n            tokenId,\\r\\n            getDataUri(tokenId),\\r\\n            getValue(tokenId),\\r\\n            getStartTimestamp(tokenId),\\r\\n            getDuration(tokenId),\\r\\n            !appeals.hasNoActiveAppeals(tokenId),\\r\\n            retrieval_deal.owner\\r\\n        );\\r\\n        return output;\\r\\n    }\\r\\n\\r\\n    // For creating a proposal for existing deals\\r\\n    function createRetrievalProposalForExistingDeal(\\r\\n        uint64 _deal_id,\\r\\n        uint256 retrieval_provider_collateral,\\r\\n        uint256 retrieval_value,\\r\\n        address[] memory _appeal_addresses\\r\\n    ) external nonReentrant {\\r\\n        // get the miner id from the deal id\\r\\n        // create a proposal with deal id, collateral and value\\r\\n        if (settings.contract_protected()) {\\r\\n            require(retrieval_value == 0, \\\"Contract is protected, can't accept value\\\");\\r\\n        }\\r\\n        require(\\r\\n            vaultStore.getBalance(msg.sender) >= retrieval_value,\\r\\n            \\\"Not enough balance to create deal proposal\\\"\\r\\n        );\\r\\n        // uint256 maximum_collateral = settings.slashing_multiplier() * value;\\r\\n        require(retrieval_value >= settings.min_deal_value(), \\\"Collateral or value out of range\\\");\\r\\n        require(_appeal_addresses.length > 0, \\\"You must define one or more appeal addresses\\\");\\r\\n        uint256 index = dealCounter.current();\\r\\n        // Creating the deal mapping\\r\\n        retrieval_deals[index].owner = msg.sender;\\r\\n        retrieval_deals[index].deal_id = _deal_id;\\r\\n        retrieval_deals[index].retrieval_provider_collateral = retrieval_provider_collateral;\\r\\n        retrieval_deals[index].retrieval_value = retrieval_value;\\r\\n        retrieval_deals[index].canceled = false;\\r\\n        retrieval_deals[index].status = Status.RequestSubmitted;\\r\\n        retrieval_deals[index].timestamp_request = block.timestamp;\\r\\n        MarketTypes.GetDealTermReturn memory term;\\r\\n        term = MarketAPI.getDealTerm(_deal_id);\\r\\n        retrieval_deals[index].term = term;\\r\\n        MarketTypes.GetDealDataCommitmentReturn memory dealCommitment;\\r\\n        dealCommitment = MarketAPI.getDealDataCommitment(_deal_id);\\r\\n        retrieval_deals[index].dealCommitment = dealCommitment;\\r\\n        retrieval_deals[index].provider_actor_id = MarketAPI.getDealProvider(_deal_id);\\r\\n        retrieval_deals[index].client_actor_id = MarketAPI.getDealClient(_deal_id);\\r\\n        for (uint256 i = 0; i < _appeal_addresses.length; i++) {\\r\\n            retrieval_deals[index].appeal_addresses[_appeal_addresses[i]] = true;\\r\\n        }\\r\\n        retrieval_deal_appeal_addresses[index] = _appeal_addresses;\\r\\n        vaultStore.sub(msg.sender, retrieval_value);\\r\\n        vaultStore.addToVault(retrieval_value);\\r\\n        // Creating next id\\r\\n        dealCounter.increment();\\r\\n        emit RetrievalDealProposalCreate(\\r\\n            index,\\r\\n            msg.sender,\\r\\n            _deal_id,\\r\\n            retrieval_provider_collateral,\\r\\n            retrieval_value,\\r\\n            _appeal_addresses\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method will allow client to cancel deal if not accepted\\r\\n    */\\r\\n    function cancelDealProposal(uint256 deal_index) external nonReentrant {\\r\\n        require(retrieval_deals[deal_index].owner == msg.sender, \\\"Only owner can cancel the deal\\\");\\r\\n        require(!retrieval_deals[deal_index].canceled, \\\"Deal canceled yet\\\");\\r\\n        // KS-PLW-03: Client can cancel the deal after it is accepted\\r\\n        require(retrieval_deals[deal_index].timestamp_start == 0, \\\"Deal accepted already\\\");\\r\\n        retrieval_deals[deal_index].canceled = true;\\r\\n        retrieval_deals[deal_index].timestamp_start = 0;\\r\\n        retrieval_deals[deal_index].status = Status.DealTerminated;\\r\\n        // Remove funds from internal vault giving back to user\\r\\n        // user will be able to withdraw funds later\\r\\n        vaultStore.subFromVault(retrieval_deals[deal_index].retrieval_value);\\r\\n        vaultStore.add(msg.sender, retrieval_deals[deal_index].retrieval_value);\\r\\n        emit DealProposalCanceled(deal_index);\\r\\n    }\\r\\n\\r\\n    function getAllDeals() external view returns (RetrievalDealReturn[] memory) {\\r\\n        RetrievalDealReturn[] memory deals = new RetrievalDealReturn[](dealCounter.current());\\r\\n        for (uint256 i = 0; i < dealCounter.current(); i++) {\\r\\n            deals[i].id = i;\\r\\n            deals[i].deal_id = retrieval_deals[i].deal_id;\\r\\n            deals[i].owner = retrieval_deals[i].owner;\\r\\n            deals[i].deal_id = retrieval_deals[i].deal_id;\\r\\n            deals[i].retrieval_provider_collateral = retrieval_deals[i]\\r\\n                .retrieval_provider_collateral;\\r\\n            deals[i].retrieval_value = retrieval_deals[i].retrieval_value;\\r\\n            deals[i].canceled = retrieval_deals[i].canceled;\\r\\n            deals[i].status = retrieval_deals[i].status;\\r\\n            deals[i].timestamp_request = retrieval_deals[i].timestamp_request;\\r\\n            deals[i].timestamp_start = retrieval_deals[i].timestamp_start;\\r\\n            deals[i].provider_actor_id = retrieval_deals[i].provider_actor_id;\\r\\n            deals[i].client_actor_id = retrieval_deals[i].client_actor_id;\\r\\n            deals[i].deal_start = CommonTypes.ChainEpoch.unwrap(retrieval_deals[i].term.start);\\r\\n            deals[i].deal_end = CommonTypes.ChainEpoch.unwrap(retrieval_deals[i].term.end);\\r\\n            deals[i].data = retrieval_deals[i].dealCommitment.data;\\r\\n            deals[i].size = retrieval_deals[i].dealCommitment.size;\\r\\n            address[] memory appeal_addresses = retrieval_deal_appeal_addresses[i];\\r\\n            bytes memory appeal_addresses_concatenated;\\r\\n            for (uint256 j = 0; j < appeal_addresses.length; j++) {\\r\\n                appeal_addresses_concatenated = abi.encodePacked(\\r\\n                    appeal_addresses_concatenated,\\r\\n                    abi.encodePacked(appeal_addresses[j])\\r\\n                );\\r\\n            }\\r\\n            deals[i].appeal_addresses = appeal_addresses_concatenated;\\r\\n        }\\r\\n        return deals;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x280688785aa0d469bb3f3c37e83bf59fa278be74243953f4b0c8281b7c7de3de\",\"license\":\"MIT\"},\"contracts/retrieve/functions/render/IRENDER.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\r\\n\\r\\ninterface IRENDER is IERC165 {\\r\\n    function render(\\r\\n        uint256 deal_index,\\r\\n        string memory data_uri,\\r\\n        uint256 value,\\r\\n        uint256 timestamp_start,\\r\\n        uint256 duration,\\r\\n        bool appeal,\\r\\n        address owner\\r\\n    ) external pure returns (string memory);\\r\\n}\\r\\n\",\"keccak256\":\"0x57d802331754166e68b47c3becb9e2a2f21e1d6b1a7cc7f7a7608758345e6b93\",\"license\":\"MIT\"},\"contracts/retrieve/libs/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\r\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\r\\n * {ERC721Enumerable}.\\r\\n */\\r\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\r\\n    using Address for address;\\r\\n    using Strings for uint256;\\r\\n\\r\\n    // Token name\\r\\n    string private _name;\\r\\n\\r\\n    // Token symbol\\r\\n    string private _symbol;\\r\\n\\r\\n    // Mapping from token ID to owner address\\r\\n    mapping(uint256 => address) private _owners;\\r\\n\\r\\n    // Mapping from token ID to approved address\\r\\n    mapping(uint256 => address) private _tokenApprovals;\\r\\n\\r\\n    // Mapping from owner to operator approvals\\r\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\r\\n     */\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(\\r\\n        bytes4 interfaceId\\r\\n    ) public view virtual override(ERC165, IERC165) returns (bool) {\\r\\n        return\\r\\n            interfaceId == type(IERC721).interfaceId ||\\r\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\r\\n            super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\r\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-ownerOf}.\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\r\\n        address owner = _owners[tokenId];\\r\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\r\\n        return owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721Metadata-name}.\\r\\n     */\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721Metadata-symbol}.\\r\\n     */\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721Metadata-tokenURI}.\\r\\n     */\\r\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\r\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\r\\n\\r\\n        string memory baseURI = _baseURI();\\r\\n        return\\r\\n            bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\r\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\r\\n     * by default, can be overriden in child contracts.\\r\\n     */\\r\\n    function _baseURI() internal view virtual returns (string memory) {\\r\\n        return \\\"\\\";\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-approve}.\\r\\n     */\\r\\n    function approve(address to, uint256 tokenId) public virtual override {\\r\\n        address owner = ERC721.ownerOf(tokenId);\\r\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\r\\n\\r\\n        require(\\r\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\r\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\r\\n        );\\r\\n\\r\\n        _approve(to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-getApproved}.\\r\\n     */\\r\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\r\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\r\\n\\r\\n        return _tokenApprovals[tokenId];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-setApprovalForAll}.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\r\\n        _setApprovalForAll(_msgSender(), operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-isApprovedForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(\\r\\n        address owner,\\r\\n        address operator\\r\\n    ) public view virtual override returns (bool) {\\r\\n        return _operatorApprovals[owner][operator];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-transferFrom}.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\r\\n        //solhint-disable-next-line max-line-length\\r\\n        require(\\r\\n            _isApprovedOrOwner(_msgSender(), tokenId),\\r\\n            \\\"ERC721: transfer caller is not owner nor approved\\\"\\r\\n        );\\r\\n\\r\\n        _transfer(from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-safeTransferFrom}.\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\r\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-safeTransferFrom}.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) public virtual override {\\r\\n        require(\\r\\n            _isApprovedOrOwner(_msgSender(), tokenId),\\r\\n            \\\"ERC721: transfer caller is not owner nor approved\\\"\\r\\n        );\\r\\n        _safeTransfer(from, to, tokenId, _data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\r\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n     *\\r\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\r\\n     *\\r\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\r\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _safeTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) internal virtual {\\r\\n        _transfer(from, to, tokenId);\\r\\n        require(\\r\\n            _checkOnERC721Received(from, to, tokenId, _data),\\r\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether `tokenId` exists.\\r\\n     *\\r\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Tokens start existing when they are minted (`_mint`),\\r\\n     * and stop existing when they are burned (`_burn`).\\r\\n     */\\r\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\r\\n        return _owners[tokenId] != address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function _isApprovedOrOwner(\\r\\n        address spender,\\r\\n        uint256 tokenId\\r\\n    ) internal view virtual returns (bool) {\\r\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\r\\n        address owner = ERC721.ownerOf(tokenId);\\r\\n        return (spender == owner ||\\r\\n            getApproved(tokenId) == spender ||\\r\\n            isApprovedForAll(owner, spender));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mints `tokenId` and transfers it to `to`.\\r\\n     *\\r\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must not exist.\\r\\n     * - `to` cannot be the zero address.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _mint(address to, uint256 tokenId) internal virtual {\\r\\n        // require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\r\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\r\\n\\r\\n        // _beforeTokenTransfer(address(0), to, tokenId);\\r\\n\\r\\n        _owners[tokenId] = to;\\r\\n\\r\\n        emit Transfer(address(0), to, tokenId);\\r\\n\\r\\n        // _afterTokenTransfer(address(0), to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `tokenId`.\\r\\n     * The approval is cleared when the token is burned.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _burn(uint256 tokenId) internal virtual {\\r\\n        address owner = ERC721.ownerOf(tokenId);\\r\\n\\r\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\r\\n\\r\\n        // Clear approvals\\r\\n        _approve(address(0), tokenId);\\r\\n\\r\\n        delete _owners[tokenId];\\r\\n\\r\\n        emit Transfer(owner, address(0), tokenId);\\r\\n\\r\\n        _afterTokenTransfer(owner, address(0), tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `tokenId` from `from` to `to`.\\r\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must be owned by `from`.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\r\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\r\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(from, to, tokenId);\\r\\n\\r\\n        // Clear approvals from the previous owner\\r\\n        _approve(address(0), tokenId);\\r\\n\\r\\n        _owners[tokenId] = to;\\r\\n\\r\\n        emit Transfer(from, to, tokenId);\\r\\n\\r\\n        _afterTokenTransfer(from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve `to` to operate on `tokenId`\\r\\n     *\\r\\n     * Emits a {Approval} event.\\r\\n     */\\r\\n    function _approve(address to, uint256 tokenId) internal virtual {\\r\\n        _tokenApprovals[tokenId] = to;\\r\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\r\\n     *\\r\\n     * Emits a {ApprovalForAll} event.\\r\\n     */\\r\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\r\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\r\\n        _operatorApprovals[owner][operator] = approved;\\r\\n        emit ApprovalForAll(owner, operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\r\\n     * The call is not executed if the target address is not a contract.\\r\\n     *\\r\\n     * @param from address representing the previous owner of the given token ID\\r\\n     * @param to target address that will receive the tokens\\r\\n     * @param tokenId uint256 ID of the token to be transferred\\r\\n     * @param _data bytes optional data to send along with the call\\r\\n     * @return bool whether the call correctly returned the expected magic value\\r\\n     */\\r\\n    function _checkOnERC721Received(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) private returns (bool) {\\r\\n        if (to.isContract()) {\\r\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (\\r\\n                bytes4 retval\\r\\n            ) {\\r\\n                return retval == IERC721Receiver.onERC721Received.selector;\\r\\n            } catch (bytes memory reason) {\\r\\n                if (reason.length == 0) {\\r\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\r\\n                } else {\\r\\n                    assembly {\\r\\n                        revert(add(32, reason), mload(reason))\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        } else {\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any token transfer. This includes minting\\r\\n     * and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\r\\n     * transferred to `to`.\\r\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\r\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual {}\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called after any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _afterTokenTransfer(address from, address to, uint256 tokenId) internal virtual {}\\r\\n}\\r\\n\",\"keccak256\":\"0xf6d73e14b07851174b2f20962b8ce335fe2c7730697ac7265e4b4d1081be151a\",\"license\":\"MIT\"},\"contracts/retrieve/providers/Providers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\nimport \\\"./../settings/Settings.sol\\\";\\r\\nimport \\\"./../deals/Deals.sol\\\";\\r\\nimport \\\"./../appeals/Appeals.sol\\\";\\r\\nimport \\\"./../vault/Vault.sol\\\";\\r\\n\\r\\ncontract Providers is Ownable, ReentrancyGuard {\\r\\n    // Defining provider struct\\r\\n    // TODO: Replace with new entry\\r\\n    struct Provider {\\r\\n        bool active;\\r\\n        string endpoint;\\r\\n        bool _exists;\\r\\n        uint64 actor_id;\\r\\n    }\\r\\n    Settings settings;\\r\\n    Deals dealsStore;\\r\\n    Appeals appealsStore;\\r\\n    Vault vaultStore;\\r\\n    // Mapping referees providers\\r\\n    mapping(address => Provider) public providers;\\r\\n    // Array of active providers\\r\\n    address[] public active_providers;\\r\\n    mapping(address => uint256[]) public provider_deals;\\r\\n    mapping(uint64 => uint256[]) public actor_id_deals;\\r\\n    // Event emitted when a deal is redeemed\\r\\n    event DealRedeemed(uint256 index);\\r\\n\\r\\n    mapping(uint64 => address) public provider_actor_id_to_eth_address;\\r\\n\\r\\n    constructor(address _settings_address, address _vault_address, address _appeals_address) {\\r\\n        settings = Settings(_settings_address);\\r\\n        appealsStore = Appeals(_appeals_address);\\r\\n        vaultStore = Vault(_vault_address);\\r\\n    }\\r\\n\\r\\n    function setDealsAddress(address _deals_address) external onlyOwner {\\r\\n        dealsStore = Deals(_deals_address);\\r\\n    }\\r\\n\\r\\n    function getAddress(uint64 _actor_id) public view returns (address) {\\r\\n        return provider_actor_id_to_eth_address[_actor_id];\\r\\n    }\\r\\n\\r\\n    function getActorId(address _address) public view returns (uint64) {\\r\\n        return providers[_address].actor_id;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * This method checks if address is provider\\r\\n     * @param _address address of provider\\r\\n     */\\r\\n    function isProvider(address _address) public pure returns (bool) {\\r\\n        return _address != address(0);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method will say if address is a provider or not\\r\\n    */\\r\\n    function providerExists(address check) public view returns (bool) {\\r\\n        return providers[check]._exists;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method will allow owner to remove a provider\\r\\n    */\\r\\n    function removeProvider(address _provider) external onlyOwner {\\r\\n        delete providers[_provider];\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method will allow provider to withdraw funds for deal\\r\\n    */\\r\\n    function redeemDeal(uint256 deal_index) external nonReentrant {\\r\\n        require(dealsStore.getOwner(deal_index) == msg.sender, \\\"Only provider can redeem\\\");\\r\\n        require(dealsStore.isActive(deal_index), \\\"Deal is not active\\\");\\r\\n        require(dealsStore.dealNotEnded(deal_index), \\\"Deal didn't ended, can't redeem\\\");\\r\\n        require(\\r\\n            appealsStore.hasNoPendingAppeals(deal_index),\\r\\n            \\\"Found a pending appeal, can't redeem\\\"\\r\\n        );\\r\\n        require(\\r\\n            appealsStore.hasNoActiveAppeals(deal_index),\\r\\n            // getRound(active_appeals[deals[deal_index].data_uri]) >= 99,\\r\\n            \\\"Found an active appeal, can't redeem\\\"\\r\\n        );\\r\\n        // KS-PLW-04: Dealer can claim bounty when deal is cancelled\\r\\n        require(!dealsStore.isCancelled(deal_index), \\\"Deal already cancelled\\\");\\r\\n\\r\\n        // Move value from contract to address\\r\\n        vaultStore.subFromVault(dealsStore.getValue(deal_index));\\r\\n        vaultStore.add(msg.sender, dealsStore.getValue(deal_index));\\r\\n\\r\\n        // Giving back collateral to provider\\r\\n        vaultStore.subFromVault(dealsStore.getCollateral(deal_index));\\r\\n        vaultStore.add(msg.sender, dealsStore.getCollateral(deal_index));\\r\\n        // Close the deal\\r\\n        dealsStore.retireDeal(deal_index);\\r\\n        emit DealRedeemed(deal_index);\\r\\n    }\\r\\n\\r\\n    // ACCEPTANCE OF DEALS BY PROVIDER\\r\\n\\r\\n    function acceptRetrievalDealProposal(uint256 deal_index) external nonReentrant {\\r\\n        require(\\r\\n            block.timestamp <\\r\\n                (dealsStore.getTimestampRequest(deal_index) + settings.proposal_timeout()) &&\\r\\n                !dealsStore.isCancelled(deal_index) &&\\r\\n                dealsStore.isProvider(deal_index, msg.sender),\\r\\n            \\\"Deal expired, canceled or not allowed to accept\\\"\\r\\n        );\\r\\n        require(\\r\\n            vaultStore.getBalance(msg.sender) >= dealsStore.getCollateral(deal_index),\\r\\n            \\\"Can't accept because you don't have enough balance in contract\\\"\\r\\n        );\\r\\n        // Mint the nft to the provider\\r\\n        dealsStore.mint(msg.sender, deal_index);\\r\\n        // _mint(msg.sender, deal_index);\\r\\n        // Activate contract\\r\\n        dealsStore.startDeal(deal_index);\\r\\n        // Deposit collateral to contract\\r\\n        vaultStore.sub(msg.sender, dealsStore.getCollateral(deal_index));\\r\\n        vaultStore.addToVault(dealsStore.getCollateral(deal_index));\\r\\n        provider_deals[msg.sender].push(deal_index);\\r\\n        actor_id_deals[providers[msg.sender].actor_id].push(deal_index);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method will return provider status in deal\\r\\n    */\\r\\n    function isProviderInDeal(uint256 deal_index, address provider) external view returns (bool) {\\r\\n        return dealsStore.isProvider(deal_index, provider);\\r\\n    }\\r\\n\\r\\n    function emulateProviderActor(string memory _endpoint, uint64 _actor_id) external {\\r\\n        require(\\r\\n            provider_actor_id_to_eth_address[_actor_id] == address(0),\\r\\n            \\\"Actor ID already exists\\\"\\r\\n        );\\r\\n        require(\\r\\n            providers[msg.sender]._exists == false,\\r\\n            \\\"Provider with this address already exists\\\"\\r\\n        );\\r\\n        providers[msg.sender]._exists = true;\\r\\n        providers[msg.sender].active = true;\\r\\n        providers[msg.sender].endpoint = _endpoint;\\r\\n        providers[msg.sender].actor_id = _actor_id;\\r\\n        provider_actor_id_to_eth_address[_actor_id] = msg.sender;\\r\\n        active_providers.push(msg.sender);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method will allow owner to enable or disable a provider\\r\\n    */\\r\\n    function setProviderStatus(\\r\\n        address _provider,\\r\\n        bool _state,\\r\\n        string memory _endpoint,\\r\\n        uint64 _actor_id\\r\\n    ) external {\\r\\n        // KS-PLW-02: Duplicate provider address is allowed\\r\\n        require(_provider != address(0x0), \\\"Invalid address\\\");\\r\\n        require(providers[_provider]._exists == false, \\\"Provider already exists\\\");\\r\\n        providers[_provider]._exists = true;\\r\\n        if (settings.permissioned_providers()) {\\r\\n            require(msg.sender == owner(), \\\"Only owner can manage providers\\\");\\r\\n        } else {\\r\\n            require(\\r\\n                _provider == msg.sender || msg.sender == owner(),\\r\\n                \\\"You can't manage another provider's state\\\"\\r\\n            );\\r\\n        }\\r\\n        providers[_provider].active = _state;\\r\\n        providers[_provider].endpoint = _endpoint;\\r\\n        providers[_provider].actor_id = _actor_id;\\r\\n        if (_state) {\\r\\n            provider_actor_id_to_eth_address[_actor_id] = _provider;\\r\\n            active_providers.push(_provider);\\r\\n        } else {\\r\\n            for (uint256 i = 0; i < active_providers.length; i++) {\\r\\n                if (active_providers[i] == _provider) {\\r\\n                    // KS-PLW-07: Vault Deposit Not Returned to Outgoing Provider\\r\\n                    require(vaultStore.getBalance(_provider) == 0, \\\"Provider Vault is not empty\\\");\\r\\n                    delete active_providers[i];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getDealsForProviderAddress(address _address) public view returns (uint256[] memory) {\\r\\n        return provider_deals[_address];\\r\\n    }\\r\\n\\r\\n    function getDealsForActorId(uint64 _actor_id) public view returns (uint256[] memory) {\\r\\n        return actor_id_deals[_actor_id];\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x154b0bdc98fa4e24f280e8bf2cb2f4bea08841418301abb631d9a09f3619bb17\",\"license\":\"MIT\"},\"contracts/retrieve/settings/Settings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"./../functions/render/IRENDER.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Settings for retrieval protocol adapted from retriev\\r\\n */\\r\\ncontract Settings is Ownable {\\r\\n    // admins\\r\\n    mapping(uint8 => mapping(address => bool)) public admins;\\r\\n    // Multipliers\\r\\n    uint256 public slashing_multiplier = 1000;\\r\\n    uint8 public committee_divider = 4;\\r\\n    // Deal parameters\\r\\n    uint32 public proposal_timeout = 86_400;\\r\\n    uint8 public max_appeals = 5;\\r\\n    uint256 public min_deal_value = 0;\\r\\n    // Round parameters\\r\\n    uint32 public round_duration = 300;\\r\\n    uint32 public min_duration = 86_400;\\r\\n    uint32 public max_duration = 31_536_000;\\r\\n    uint8 public slashes_threshold = 12;\\r\\n    uint8 public rounds_limit = 12;\\r\\n    // Render contract\\r\\n    IRENDER public token_render;\\r\\n    // Contract state variables\\r\\n    bool public contract_protected = false;\\r\\n    bool public permissioned_providers = false;\\r\\n    // Protocol address\\r\\n    address public protocol_address;\\r\\n\\r\\n    constructor(address _protocol_address) {\\r\\n        require(_protocol_address != address(0), \\\"Can't init protocol with black-hole\\\");\\r\\n        protocol_address = _protocol_address;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        Admin function to setup roles\\r\\n    */\\r\\n\\r\\n    function setRole(uint8 kind, bool status, address admin) external {\\r\\n        // Set specified role, using:\\r\\n        // 1 - Protocol managers\\r\\n        // 2 - Referees managers\\r\\n        // 3 - Providers managers\\r\\n        admins[kind][admin] = status;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        Admin functions to fine tune protocol\\r\\n    */\\r\\n    function tuneRefereesVariables(uint8 kind, uint8 value8, uint32 value32) external {\\r\\n        require(msg.sender == owner() || admins[2][msg.sender], \\\"Can't manage referees variables\\\");\\r\\n        if (kind == 0) {\\r\\n            committee_divider = value8;\\r\\n        } else if (kind == 1) {\\r\\n            max_appeals = value8;\\r\\n        } else if (kind == 2) {\\r\\n            round_duration = value32;\\r\\n        } else if (kind == 3) {\\r\\n            rounds_limit = value8;\\r\\n        } else if (kind == 4) {\\r\\n            slashes_threshold = value8;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tuneProvidersVariables(uint8 kind, uint256 value256, uint32 value32) external {\\r\\n        require(msg.sender == owner() || admins[3][msg.sender], \\\"Can't manage providers variables\\\");\\r\\n        if (kind == 0) {\\r\\n            proposal_timeout = value32;\\r\\n        } else if (kind == 1) {\\r\\n            min_deal_value = value256;\\r\\n        } else if (kind == 2) {\\r\\n            slashing_multiplier = value256;\\r\\n        } else if (kind == 3) {\\r\\n            min_duration = value32;\\r\\n        } else if (kind == 4) {\\r\\n            max_duration = value32;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tuneProtocolVariables(uint8 kind, address addy, bool state) external {\\r\\n        require(msg.sender == owner() || admins[1][msg.sender], \\\"Can't manage protocol variables\\\");\\r\\n        if (kind == 0) {\\r\\n            token_render = IRENDER(addy);\\r\\n        } else if (kind == 1) {\\r\\n            protocol_address = addy;\\r\\n        } else if (kind == 2) {\\r\\n            contract_protected = state;\\r\\n        } else if (kind == 3) {\\r\\n            permissioned_providers = state;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xb86002576dcd222a7fc62fe7e252f3583c382ce36e8cbe0e4bda109a786a4cc7\",\"license\":\"MIT\"},\"contracts/retrieve/vault/Vault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\r\\nimport \\\"./../settings/Settings.sol\\\";\\r\\n\\r\\ncontract Vault is ReentrancyGuard, AccessControl {\\r\\n    // Referee, Providers and Clients vault\\r\\n    mapping(address => uint256) public vault;\\r\\n    bytes32 public constant APPEALS_ROLE = keccak256(\\\"APPEALS_ROLE\\\");\\r\\n    bytes32 public constant DEALS_ROLE = keccak256(\\\"DEALS_ROLE\\\");\\r\\n    bytes32 public constant PROVIDERS_ROLE = keccak256(\\\"PROVIDERS_ROLE\\\");\\r\\n    bytes32 public constant ADMIN_ROLE = keccak256(\\\"ADMIN_ROLE\\\");\\r\\n    Settings settings;\\r\\n\\r\\n    constructor(Settings _settings_address) {\\r\\n        _grantRole(ADMIN_ROLE, msg.sender);\\r\\n        settings = Settings(_settings_address);\\r\\n    }\\r\\n\\r\\n    function setAppealsRole(address _address) external {\\r\\n        require(hasRole(ADMIN_ROLE, msg.sender), \\\"Caller is not an admin\\\");\\r\\n        _grantRole(APPEALS_ROLE, _address);\\r\\n    }\\r\\n\\r\\n    function setProvidersRole(address _address) external {\\r\\n        require(hasRole(ADMIN_ROLE, msg.sender), \\\"Caller is not an admin\\\");\\r\\n        _grantRole(PROVIDERS_ROLE, _address);\\r\\n    }\\r\\n\\r\\n    function setDealsRole(address _address) external {\\r\\n        require(hasRole(ADMIN_ROLE, msg.sender), \\\"Caller is not an admin\\\");\\r\\n        _grantRole(DEALS_ROLE, _address);\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method will allow provider deposit ETH in order to accept deals\\r\\n    */\\r\\n    function depositToVault() external payable nonReentrant {\\r\\n        // require(isProvider(msg.sender), \\\"Only providers can deposit into contract\\\");\\r\\n        require(msg.value > 0, \\\"Must send some value\\\");\\r\\n        vault[msg.sender] += msg.value;\\r\\n    }\\r\\n\\r\\n    /*\\r\\n        This method will allow to withdraw ethers from contract\\r\\n    */\\r\\n    function withdrawFromVault(uint256 amount) external nonReentrant {\\r\\n        uint256 balance = vault[msg.sender];\\r\\n        require(balance >= amount, \\\"Not enough balance to withdraw\\\");\\r\\n        vault[msg.sender] -= amount;\\r\\n        bool success;\\r\\n        (success, ) = payable(msg.sender).call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Withdraw to user failed\\\");\\r\\n    }\\r\\n\\r\\n    function getProtocolBalance() public view returns (uint256) {\\r\\n        return vault[settings.protocol_address()];\\r\\n    }\\r\\n\\r\\n    function transferProtocolBalance(uint256 amount) external nonReentrant {\\r\\n        require(hasRole(ADMIN_ROLE, msg.sender), \\\"Caller is not authorized\\\");\\r\\n        uint256 balance = vault[settings.protocol_address()];\\r\\n        require(balance >= amount, \\\"Not enough balance to withdraw\\\");\\r\\n        vault[settings.protocol_address()] -= amount;\\r\\n        bool success;\\r\\n        (success, ) = payable(msg.sender).call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Withdraw to user failed\\\");\\r\\n    }\\r\\n\\r\\n    function setValue(address _address, uint256 _value) public {\\r\\n        require(\\r\\n            hasRole(APPEALS_ROLE, msg.sender) ||\\r\\n                hasRole(DEALS_ROLE, msg.sender) ||\\r\\n                hasRole(PROVIDERS_ROLE, msg.sender),\\r\\n            \\\"Caller is not authorized\\\"\\r\\n        );\\r\\n        vault[_address] = _value;\\r\\n    }\\r\\n\\r\\n    function sub(address _address, uint256 _value) public {\\r\\n        require(\\r\\n            hasRole(APPEALS_ROLE, msg.sender) ||\\r\\n                hasRole(DEALS_ROLE, msg.sender) ||\\r\\n                hasRole(PROVIDERS_ROLE, msg.sender),\\r\\n            \\\"Caller is not authorized\\\"\\r\\n        );\\r\\n        vault[_address] -= _value;\\r\\n    }\\r\\n\\r\\n    function add(address _address, uint256 _value) public {\\r\\n        require(\\r\\n            hasRole(APPEALS_ROLE, msg.sender) ||\\r\\n                hasRole(DEALS_ROLE, msg.sender) ||\\r\\n                hasRole(PROVIDERS_ROLE, msg.sender),\\r\\n            \\\"Caller is not authorized\\\"\\r\\n        );\\r\\n        vault[_address] += _value;\\r\\n    }\\r\\n\\r\\n    function addToVault(uint256 _value) public {\\r\\n        require(\\r\\n            hasRole(APPEALS_ROLE, msg.sender) ||\\r\\n                hasRole(DEALS_ROLE, msg.sender) ||\\r\\n                hasRole(PROVIDERS_ROLE, msg.sender),\\r\\n            \\\"Caller is not authorized\\\"\\r\\n        );\\r\\n        vault[address(this)] += _value;\\r\\n    }\\r\\n\\r\\n    function subFromVault(uint256 _value) public {\\r\\n        require(\\r\\n            hasRole(APPEALS_ROLE, msg.sender) ||\\r\\n                hasRole(DEALS_ROLE, msg.sender) ||\\r\\n                hasRole(PROVIDERS_ROLE, msg.sender),\\r\\n            \\\"Caller is not authorized\\\"\\r\\n        );\\r\\n        vault[address(this)] -= _value;\\r\\n    }\\r\\n\\r\\n    function addToProtocol(uint256 _value) public {\\r\\n        require(\\r\\n            hasRole(APPEALS_ROLE, msg.sender) ||\\r\\n                hasRole(DEALS_ROLE, msg.sender) ||\\r\\n                hasRole(PROVIDERS_ROLE, msg.sender),\\r\\n            \\\"Caller is not authorized\\\"\\r\\n        );\\r\\n        vault[settings.protocol_address()] += _value;\\r\\n    }\\r\\n\\r\\n    function getBalance(address _address) public view returns (uint256) {\\r\\n        return vault[_address];\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xc779ac0494e3efa2560c7a1dcee531b615563446a3d83cd3babbabd80536df12\",\"license\":\"MIT\"},\"solidity-cborutils/contracts/CBOR.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\n\\n/**\\n* @dev A library for populating CBOR encoded payload in Solidity.\\n*\\n* https://datatracker.ietf.org/doc/html/rfc7049\\n*\\n* The library offers various write* and start* methods to encode values of different types.\\n* The resulted buffer can be obtained with data() method.\\n* Encoding of primitive types is staightforward, whereas encoding of sequences can result\\n* in an invalid CBOR if start/write/end flow is violated.\\n* For the purpose of gas saving, the library does not verify start/write/end flow internally,\\n* except for nested start/end pairs.\\n*/\\n\\nlibrary CBOR {\\n    using Buffer for Buffer.buffer;\\n\\n    struct CBORBuffer {\\n        Buffer.buffer buf;\\n        uint256 depth;\\n    }\\n\\n    uint8 private constant MAJOR_TYPE_INT = 0;\\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\\n    uint8 private constant MAJOR_TYPE_STRING = 3;\\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\\n    uint8 private constant MAJOR_TYPE_MAP = 5;\\n    uint8 private constant MAJOR_TYPE_TAG = 6;\\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\\n\\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\\n\\n    uint8 private constant CBOR_FALSE = 20;\\n    uint8 private constant CBOR_TRUE = 21;\\n    uint8 private constant CBOR_NULL = 22;\\n    uint8 private constant CBOR_UNDEFINED = 23;\\n\\n    function create(uint256 capacity) internal pure returns(CBORBuffer memory cbor) {\\n        Buffer.init(cbor.buf, capacity);\\n        cbor.depth = 0;\\n        return cbor;\\n    }\\n\\n    function data(CBORBuffer memory buf) internal pure returns(bytes memory) {\\n        require(buf.depth == 0, \\\"Invalid CBOR\\\");\\n        return buf.buf.buf;\\n    }\\n\\n    function writeUInt256(CBORBuffer memory buf, uint256 value) internal pure {\\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\\n        writeBytes(buf, abi.encode(value));\\n    }\\n\\n    function writeInt256(CBORBuffer memory buf, int256 value) internal pure {\\n        if (value < 0) {\\n            buf.buf.appendUint8(\\n                uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM)\\n            );\\n            writeBytes(buf, abi.encode(uint256(-1 - value)));\\n        } else {\\n            writeUInt256(buf, uint256(value));\\n        }\\n    }\\n\\n    function writeUInt64(CBORBuffer memory buf, uint64 value) internal pure {\\n        writeFixedNumeric(buf, MAJOR_TYPE_INT, value);\\n    }\\n\\n    function writeInt64(CBORBuffer memory buf, int64 value) internal pure {\\n        if(value >= 0) {\\n            writeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\\n        } else{\\n            writeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(-1 - value));\\n        }\\n    }\\n\\n    function writeBytes(CBORBuffer memory buf, bytes memory value) internal pure {\\n        writeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\\n        buf.buf.append(value);\\n    }\\n\\n    function writeString(CBORBuffer memory buf, string memory value) internal pure {\\n        writeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\\n        buf.buf.append(bytes(value));\\n    }\\n\\n    function writeBool(CBORBuffer memory buf, bool value) internal pure {\\n        writeContentFree(buf, value ? CBOR_TRUE : CBOR_FALSE);\\n    }\\n\\n    function writeNull(CBORBuffer memory buf) internal pure {\\n        writeContentFree(buf, CBOR_NULL);\\n    }\\n\\n    function writeUndefined(CBORBuffer memory buf) internal pure {\\n        writeContentFree(buf, CBOR_UNDEFINED);\\n    }\\n\\n    function startArray(CBORBuffer memory buf) internal pure {\\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\\n        buf.depth += 1;\\n    }\\n\\n    function startFixedArray(CBORBuffer memory buf, uint64 length) internal pure {\\n        writeDefiniteLengthType(buf, MAJOR_TYPE_ARRAY, length);\\n    }\\n\\n    function startMap(CBORBuffer memory buf) internal pure {\\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\\n        buf.depth += 1;\\n    }\\n\\n    function startFixedMap(CBORBuffer memory buf, uint64 length) internal pure {\\n        writeDefiniteLengthType(buf, MAJOR_TYPE_MAP, length);\\n    }\\n\\n    function endSequence(CBORBuffer memory buf) internal pure {\\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\\n        buf.depth -= 1;\\n    }\\n\\n    function writeKVString(CBORBuffer memory buf, string memory key, string memory value) internal pure {\\n        writeString(buf, key);\\n        writeString(buf, value);\\n    }\\n\\n    function writeKVBytes(CBORBuffer memory buf, string memory key, bytes memory value) internal pure {\\n        writeString(buf, key);\\n        writeBytes(buf, value);\\n    }\\n\\n    function writeKVUInt256(CBORBuffer memory buf, string memory key, uint256 value) internal pure {\\n        writeString(buf, key);\\n        writeUInt256(buf, value);\\n    }\\n\\n    function writeKVInt256(CBORBuffer memory buf, string memory key, int256 value) internal pure {\\n        writeString(buf, key);\\n        writeInt256(buf, value);\\n    }\\n\\n    function writeKVUInt64(CBORBuffer memory buf, string memory key, uint64 value) internal pure {\\n        writeString(buf, key);\\n        writeUInt64(buf, value);\\n    }\\n\\n    function writeKVInt64(CBORBuffer memory buf, string memory key, int64 value) internal pure {\\n        writeString(buf, key);\\n        writeInt64(buf, value);\\n    }\\n\\n    function writeKVBool(CBORBuffer memory buf, string memory key, bool value) internal pure {\\n        writeString(buf, key);\\n        writeBool(buf, value);\\n    }\\n\\n    function writeKVNull(CBORBuffer memory buf, string memory key) internal pure {\\n        writeString(buf, key);\\n        writeNull(buf);\\n    }\\n\\n    function writeKVUndefined(CBORBuffer memory buf, string memory key) internal pure {\\n        writeString(buf, key);\\n        writeUndefined(buf);\\n    }\\n\\n    function writeKVMap(CBORBuffer memory buf, string memory key) internal pure {\\n        writeString(buf, key);\\n        startMap(buf);\\n    }\\n\\n    function writeKVArray(CBORBuffer memory buf, string memory key) internal pure {\\n        writeString(buf, key);\\n        startArray(buf);\\n    }\\n\\n    function writeFixedNumeric(\\n        CBORBuffer memory buf,\\n        uint8 major,\\n        uint64 value\\n    ) private pure {\\n        if (value <= 23) {\\n            buf.buf.appendUint8(uint8((major << 5) | value));\\n        } else if (value <= 0xFF) {\\n            buf.buf.appendUint8(uint8((major << 5) | 24));\\n            buf.buf.appendInt(value, 1);\\n        } else if (value <= 0xFFFF) {\\n            buf.buf.appendUint8(uint8((major << 5) | 25));\\n            buf.buf.appendInt(value, 2);\\n        } else if (value <= 0xFFFFFFFF) {\\n            buf.buf.appendUint8(uint8((major << 5) | 26));\\n            buf.buf.appendInt(value, 4);\\n        } else {\\n            buf.buf.appendUint8(uint8((major << 5) | 27));\\n            buf.buf.appendInt(value, 8);\\n        }\\n    }\\n\\n    function writeIndefiniteLengthType(CBORBuffer memory buf, uint8 major)\\n        private\\n        pure\\n    {\\n        buf.buf.appendUint8(uint8((major << 5) | 31));\\n    }\\n\\n    function writeDefiniteLengthType(CBORBuffer memory buf, uint8 major, uint64 length)\\n        private\\n        pure\\n    {\\n        writeFixedNumeric(buf, major, length);\\n    }\\n\\n    function writeContentFree(CBORBuffer memory buf, uint8 value) private pure {\\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_CONTENT_FREE << 5) | value));\\n    }\\n}\",\"keccak256\":\"0xe03d8889bf66e7a30e8010b022b6c86ad0f8c19764cc6c7f50b6bb4ad860cb9b\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b50604051620038b5380380620038b58339810160408190526200003491620000ff565b6200003f3362000075565b60018055600280546001600160a01b039384166001600160a01b0319918216179091556004805492909316911617905562000142565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60006001600160a01b0382165b92915050565b620000e381620000c5565b8114620000ef57600080fd5b50565b8051620000d281620000d8565b60008060408385031215620001175762000117600080fd5b6000620001258585620000f2565b92505060206200013885828601620000f2565b9150509250929050565b61376380620001526000396000f3fe608060405234801561001057600080fd5b50600436106101ae5760003560e01c806388ca9d2f116100ee578063a008d89311610097578063acff868711610071578063acff8687146103ee578063f0b070ca1461044a578063f2fde38b1461045d578063f3c4e5f21461047057600080fd5b8063a008d8931461038f578063a44afce2146103bb578063ace71f63146103db57600080fd5b80638f1327c0116100c85780638f1327c01461033857806392bf42891461034b5780639414b9021461036f57600080fd5b806388ca9d2f146102f457806388f8724d146103075780638da5cb5b1461032757600080fd5b806339ab480a1161015b5780636aa921cd116101355780636aa921cd146102a6578063715018a6146102b957806383a0dbfe146102c157806386478a0a146102e157600080fd5b806339ab480a146102425780633d3030391461025557806364a60b471461028557600080fd5b8063212180811161018c57806321218081146102075780633889107f1461021c57806338b1f7521461022f57600080fd5b80630e1f06fb146101b357806314d967d1146101ea5780631fa879e8146101ff575b600080fd5b6101d46101c13660046123ed565b6000908152600960205260409020541590565b6040516101e19190612420565b60405180910390f35b6101f2610483565b6040516101e19190612434565b6101f26104a9565b61021a6102153660046123ed565b6104b9565b005b61021a61022a366004612535565b61058d565b6101d461023d366004612595565b61062a565b6101f26102503660046123ed565b6106be565b6102786102633660046123ed565b60086020526000908152604090205460ff1681565b6040516101e191906125db565b6102986102933660046125e9565b6107ba565b6040516101e1929190612660565b61021a6102b43660046127b5565b610863565b61021a61113c565b6101f26102cf3660046123ed565b60096020526000908152604090205481565b61021a6102ef3660046125e9565b611150565b61021a61030236600461284e565b61117a565b61031a6103153660046123ed565b6112ab565b6040516101e191906128b8565b6000546001600160a01b031661031a565b6101f26103463660046123ed565b611366565b6101d46103593660046123ed565b6000908152600a60205260409020546063111590565b61038261037d3660046123ed565b6115cb565b6040516101e191906128c6565b6101d461039d3660046125e9565b6001600160a01b031660009081526005602052604090205460ff1690565b6101f26103c93660046123ed565b600a6020526000908152604090205481565b6101d46103e93660046128d7565b61162d565b6104396103fc3660046123ed565b60076020526000908152604090208054600182015460038301546004840154600590940154929360ff909216926001600160801b03909116919085565b6040516101e1959493929190612946565b61021a6104583660046123ed565b6116a5565b61021a61046b3660046125e9565b611d05565b61031a61047e3660046123ed565b611d3c565b60065460009081906002906104999060646129a8565b6104a391906129dd565b92915050565b60006104b4600b5490565b905090565b600081815260076020526040902060050154156104f15760405162461bcd60e51b81526004016104e890612a28565b60405180910390fd5b3360009081526005602052604090205460ff166105205760405162461bcd60e51b81526004016104e890612a6c565b60008181526007602090815260408083204260058201558054845260098352818420849055548352600a90915290819020829055517f5f2f99bd7614bf1ceaf9ef1d2e1a64cf8de13e424ae866a950717befe7b05de290610582908390612434565b60405180910390a150565b3360009081526005602052604090205460ff16156105bd5760405162461bcd60e51b81526004016104e890612ad9565b336000908152600560205260409020805460ff191660019081178255016105e48282612bcf565b5050600680546001810182556000919091527ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f0180546001600160a01b03191633179055565b6003546040517f02a8fbaf0000000000000000000000000000000000000000000000000000000081526000916001600160a01b0316906302a8fbaf906106769086908690600401612c92565b602060405180830381865afa158015610693573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106b79190612cb8565b9392505050565b600080600260009054906101000a90046001600160a01b03166001600160a01b0316632fe586116040518163ffffffff1660e01b8152600401602060405180830381865afa158015610714573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107389190612ced565b6003546040516307fa648b60e11b815260ff92909216916001600160a01b0390911690630ff4c9169061076f908790600401612434565b602060405180830381865afa15801561078c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107b09190612d19565b6106b791906129dd565b6005602052600090815260409020805460018201805460ff90921692916107e090612aff565b80601f016020809104026020016040519081016040528092919081815260200182805461080c90612aff565b80156108595780601f1061082e57610100808354040283529160200191610859565b820191906000526020600020905b81548152906001019060200180831161083c57829003601f168201915b5050505050905082565b6000838152600a60205260408120549061087c82611366565b905061088783611d66565b156108a45760405162461bcd60e51b81526004016104e890612d94565b6003546040516382afd23b60e01b81526001600160a01b03909116906382afd23b906108d4908890600401612434565b602060405180830381865afa1580156108f1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109159190612cb8565b6109315760405162461bcd60e51b81526004016104e890612dd8565b60008281526007602052604090206001015460ff166109625760405162461bcd60e51b81526004016104e890612e1c565b3360009081526005602052604090205460ff166109915760405162461bcd60e51b81526004016104e890612e86565b600260009054906101000a90046001600160a01b03166001600160a01b031663335d4d5b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156109e4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a089190612ced565b60ff16811115610a2a5760405162461bcd60e51b81526004016104e890612ef0565b600082815260076020908152604080832084845260020190915290205460ff1615610a675760405162461bcd60e51b81526004016104e890612f34565b60008281526007602090815260408083208484526002019091528120805460ff1916600117905533610a98846112ab565b6001600160a01b031603610afa57600083815260076020526040812060030180546001600160801b031691610acc83612f44565b91906101000a8154816001600160801b0302191690836001600160801b031602179055505060019050610bea565b60005b8551811015610b7e576000868281518110610b1a57610b1a612f85565b602002602001015190506000868381518110610b3857610b38612f85565b60200260200101519050610b4d818a8461162d565b610b695760405162461bcd60e51b81526004016104e890612fcf565b50508080610b7690612fdf565b915050610afd565b50610b87610483565b8451610b949060646129a8565b1115610bea57600083815260076020526040812060030180546001600160801b031691610bc083612f44565b91906101000a8154816001600160801b0302191690836001600160801b0316021790555050600190505b80610c075760405162461bcd60e51b81526004016104e89061304c565b7fa1c5ef3d5097627088df57042f85d34fffc6946dc075a6c46c90f11ba02f11b283604051610c369190612434565b60405180910390a1600260009054906101000a90046001600160a01b03166001600160a01b0316636522514f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c91573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cb59190612ced565b60008481526007602052604090206003015460ff919091166001600160801b0390911610611134576003546040517f1f77f6a80000000000000000000000000000000000000000000000000000000081526001600160a01b0390911690631f77f6a890610d26908990600401612434565b600060405180830381600087803b158015610d4057600080fd5b505af1158015610d54573d6000803e3d6000fd5b50505060008481526007602052604090819020600101805460ff191690556004805460035492516307fa648b60e11b81526001600160a01b03918216945063f33e22529390911691630ff4c91691610dae918c9101612434565b602060405180830381865afa158015610dcb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610def9190612d19565b6040518263ffffffff1660e01b8152600401610e0b9190612434565b600060405180830381600087803b158015610e2557600080fd5b505af1158015610e39573d6000803e3d6000fd5b50506004805460035460405163620d1b0560e11b81526001600160a01b03928316955063f5d82b6b945091169163c41a360a91610e78918c9101612434565b602060405180830381865afa158015610e95573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eb99190613067565b6003546040516307fa648b60e11b81526001600160a01b0390911690630ff4c91690610ee9908c90600401612434565b602060405180830381865afa158015610f06573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f2a9190612d19565b6040518363ffffffff1660e01b8152600401610f47929190613088565b600060405180830381600087803b158015610f6157600080fd5b505af1158015610f75573d6000803e3d6000fd5b50506003546040517f2a62a490000000000000000000000000000000000000000000000000000000008152600093506001600160a01b039091169150632a62a49090610fc5908a90600401612434565b602060405180830381865afa158015610fe2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110069190612d19565b600480546040517ff33e22520000000000000000000000000000000000000000000000000000000081529293506001600160a01b03169163f33e22529161104f91859101612434565b600060405180830381600087803b15801561106957600080fd5b505af115801561107d573d6000803e3d6000fd5b5050600480546040517f98c991b30000000000000000000000000000000000000000000000000000000081526001600160a01b0390911693506398c991b392506110c991859101612434565b600060405180830381600087803b1580156110e357600080fd5b505af11580156110f7573d6000803e3d6000fd5b505050507f6d23472f0f752e5a870afc2dc90ac634638d1333424ca7e389afe92815383b278760405161112a9190612434565b60405180910390a1505b505050505050565b611144611eb9565b61114e6000611ee3565b565b611158611eb9565b600380546001600160a01b0319166001600160a01b0392909216919091179055565b611182611eb9565b8115611245576001600160a01b03831660009081526005602052604090205460ff16156111c15760405162461bcd60e51b81526004016104e890612ad9565b6001600160a01b0383166000908152600560205260409020805460ff19168315151781556001016111f28282612bcf565b50600680546001810182556000919091527ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f0180546001600160a01b0385166001600160a01b0319909116179055505050565b60005b6006548110156112a457836001600160a01b03166006828154811061126f5761126f612f85565b6000918252602090912001546001600160a01b0316036112925761129281611f33565b8061129c81612fdf565b915050611248565b505b505050565b6000806112b783611366565b6000848152600760205260408120600501549192509082906112da9086906130a3565b6112e491906130a3565b6040516020016112f491906130b6565b60408051601f19818403018152919052805160209091012060065490915060009061131f81846129dd565b61132991906129a8565b61133390836130cb565b90506006818154811061134857611348612f85565b6000918252602090912001546001600160a01b031695945050505050565b600080600260009054906101000a90046001600160a01b03166001600160a01b031663335d4d5b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156113bc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113e09190612ced565b60ff16600260009054906101000a90046001600160a01b03166001600160a01b031663d1b04e9e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611436573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061145a91906130f5565b6114649190613116565b60008481526007602052604081206005015463ffffffff9290921692509061148d9083906130a3565b90504281106115c15760006114a242836130cb565b90506000600260009054906101000a90046001600160a01b03166001600160a01b031663d1b04e9e6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156114f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061151d91906130f5565b61152d9063ffffffff16836129dd565b9050600081600260009054906101000a90046001600160a01b03166001600160a01b031663335d4d5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611585573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115a99190612ced565b60ff166115b691906130cb565b979650505050505050565b5060639392505050565b6000818152600760205260408120546060916115e684611366565b90506115f182612027565b6115fa85612027565b61160383612027565b6040516020016116159392919061315b565b60405160208183030381529060405292505050919050565b6001600160a01b03811660009081526005602052604081205460ff166116655760405162461bcd60e51b81526004016104e8906131e2565b6000611670846115cb565b9050600061167d826120c8565b9050600061168b8288612103565b6001600160a01b0386811691161493505050509392505050565b6116ad61211f565b600260009054906101000a90046001600160a01b03166001600160a01b031663e13f8e6c6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611700573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117249190612ced565b60008281526008602052604090205460ff9182169116106117575760405162461bcd60e51b81526004016104e89061324c565b6003546040516382afd23b60e01b81526001600160a01b03909116906382afd23b90611787908490600401612434565b602060405180830381865afa1580156117a4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117c89190612cb8565b6117e45760405162461bcd60e51b81526004016104e890612dd8565b6003546040517f688f216e0000000000000000000000000000000000000000000000000000000081526001600160a01b039091169063688f216e9061182d908490600401612434565b602060405180830381865afa15801561184a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061186e9190612cb8565b61188a5760405162461bcd60e51b81526004016104e89061328e565b6003546040517f5a5d096c0000000000000000000000000000000000000000000000000000000081526001600160a01b0390911690635a5d096c906118d59084903390600401612c92565b602060405180830381865afa1580156118f2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119169190612cb8565b6119325760405162461bcd60e51b81526004016104e8906132f8565b6000818152600960205260409020541561195e5760405162461bcd60e51b81526004016104e89061333a565b6000818152600a6020526040902054158061199257506000818152600a602052604090205460639061198f90611366565b10155b6119ae5760405162461bcd60e51b81526004016104e8906133a4565b6119b7816106be565b600480546040517ff8b2cb4f0000000000000000000000000000000000000000000000000000000081526001600160a01b039091169163f8b2cb4f916119ff913391016128b8565b602060405180830381865afa158015611a1c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a409190612d19565b1015611a5e5760405162461bcd60e51b81526004016104e89061340e565b6004546001600160a01b03166326ffee0833611a79846106be565b6040518363ffffffff1660e01b8152600401611a96929190613088565b600060405180830381600087803b158015611ab057600080fd5b505af1158015611ac4573d6000803e3d6000fd5b505050506000611ad3826106be565b6000838152600860205260408120805492935060ff9092169190611af68361341e565b91906101000a81548160ff021916908360ff160217905550506000811115611bf957600654600090611b2890836129dd565b905060005b600654811015611bf657600454600680546001600160a01b039092169163f5d82b6b919084908110611b6157611b61612f85565b6000918252602090912001546040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b168152611bb1916001600160a01b0316908690600401613088565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b505050508080611bee90612fdf565b915050611b2d565b50505b611c07600b80546001019055565b6000611c12600b5490565b60008481526009602090815260408083208490558383526007909152908190208581556001808201805460ff1916909117905542600491820155600354915163620d1b0560e11b81529293507ff56725243f2f0a402c5adb1e89c210b1486962a45b63f1768a2fdccae95e6f359284926001600160a01b03169163c41a360a91611c9e91899101612434565b602060405180830381865afa158015611cbb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cdf9190613067565b85604051611cef93929190613434565b60405180910390a15050611d0260018055565b50565b611d0d611eb9565b6001600160a01b038116611d335760405162461bcd60e51b81526004016104e8906134b6565b611d0281611ee3565b60068181548110611d4c57600080fd5b6000918252602090912001546001600160a01b0316905081565b60008151600003611d7957506000919050565b60005b60018351611d8a91906130cb565b811015611eb0576000611d9e8260016130a3565b90505b8351811015611e9d576002848281518110611dbe57611dbe612f85565b6020026020010151604051611dd391906134c6565b602060405180830381855afa158015611df0573d6000803e3d6000fd5b5050506040513d601f19601f82011682018060405250810190611e139190612d19565b6002858481518110611e2757611e27612f85565b6020026020010151604051611e3c91906134c6565b602060405180830381855afa158015611e59573d6000803e3d6000fd5b5050506040513d601f19601f82011682018060405250810190611e7c9190612d19565b03611e8b575060019392505050565b80611e9581612fdf565b915050611da1565b5080611ea881612fdf565b915050611d7c565b50600092915050565b6000546001600160a01b0316331461114e5760405162461bcd60e51b81526004016104e890613504565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6006548110611f545760405162461bcd60e51b81526004016104e890613548565b805b600654611f65906001906130cb565b811015611ff0576006611f798260016130a3565b81548110611f8957611f89612f85565b600091825260209091200154600680546001600160a01b039092169183908110611fb557611fb5612f85565b600091825260209091200180546001600160a01b0319166001600160a01b039290921691909117905580611fe881612fdf565b915050611f56565b50600680548061200257612002613558565b600082815260209020810160001990810180546001600160a01b031916905501905550565b6060600061203483612148565b600101905060008167ffffffffffffffff81111561205457612054612442565b6040519080825280601f01601f19166020018201604052801561207e576020820181803683370190505b5090508181016020015b600019017f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8504945084612088575b509392505050565b60006120d48251612027565b826040516020016120e692919061356e565b604051602081830303815290604052805190602001209050919050565b6000806000612112858561222a565b915091506120c08161226f565b6002600154036121415760405162461bcd60e51b81526004016104e8906135e0565b6002600155565b6000807a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008310612191577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000830492506040015b6d04ee2d6d415b85acef810000000083106121bd576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc1000083106121db57662386f26fc10000830492506010015b6305f5e10083106121f3576305f5e100830492506008015b612710831061220757612710830492506004015b60648310612219576064830492506002015b600a83106104a35760010192915050565b60008082516041036122605760208301516040840151606085015160001a6122548782858561231e565b94509450505050612268565b506000905060025b9250929050565b6000816004811115612283576122836135f0565b0361228b5750565b600181600481111561229f5761229f6135f0565b036122bc5760405162461bcd60e51b81526004016104e89061363a565b60028160048111156122d0576122d06135f0565b036122ed5760405162461bcd60e51b81526004016104e89061367e565b6003816004811115612301576123016135f0565b03611d025760405162461bcd60e51b81526004016104e8906136e8565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a083111561235557506000905060036123cc565b60006001878787876040516000815260200160405260405161237a94939291906136f8565b6020604051602081039080840390855afa15801561239c573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b0381166123c5576000600192509250506123cc565b9150600090505b94509492505050565b805b8114611d0257600080fd5b80356104a3816123d5565b60006020828403121561240257612402600080fd5b600061240e84846123e2565b949350505050565b8015155b82525050565b602081016104a38284612416565b8061241a565b602081016104a3828461242e565b634e487b7160e01b600052604160045260246000fd5b601f19601f830116810181811067ffffffffffffffff8211171561247e5761247e612442565b6040525050565b600061249060405190565b905061249c8282612458565b919050565b600067ffffffffffffffff8211156124bb576124bb612442565b601f19601f83011660200192915050565b82818337506000910152565b60006124eb6124e6846124a1565b612485565b90508281526020810184848401111561250657612506600080fd5b6120c08482856124cc565b600082601f83011261252557612525600080fd5b813561240e8482602086016124d8565b60006020828403121561254a5761254a600080fd5b813567ffffffffffffffff81111561256457612564600080fd5b61240e84828501612511565b60006001600160a01b0382166104a3565b6123d781612570565b80356104a381612581565b600080604083850312156125ab576125ab600080fd5b60006125b785856123e2565b92505060206125c88582860161258a565b9150509250929050565b60ff811661241a565b602081016104a382846125d2565b6000602082840312156125fe576125fe600080fd5b600061240e848461258a565b60005b8381101561262557818101518382015260200161260d565b50506000910152565b6000612638825190565b80845260208401935061264f81856020860161260a565b601f01601f19169290920192915050565b6040810161266e8285612416565b818103602083015261240e818461262e565b600067ffffffffffffffff82111561269a5761269a612442565b5060209081020190565b60006126b26124e684612680565b838152905060208082019084028301858111156126d1576126d1600080fd5b835b818110156126f557806126e6888261258a565b845250602092830192016126d3565b5050509392505050565b600082601f83011261271357612713600080fd5b813561240e8482602086016126a4565b60006127316124e684612680565b8381529050602080820190840283018581111561275057612750600080fd5b835b818110156126f557803567ffffffffffffffff81111561277457612774600080fd5b8086016127818982612511565b8552505060209283019201612752565b600082601f8301126127a5576127a5600080fd5b813561240e848260208601612723565b6000806000606084860312156127cd576127cd600080fd5b60006127d986866123e2565b935050602084013567ffffffffffffffff8111156127f9576127f9600080fd5b612805868287016126ff565b925050604084013567ffffffffffffffff81111561282557612825600080fd5b61283186828701612791565b9150509250925092565b8015156123d7565b80356104a38161283b565b60008060006060848603121561286657612866600080fd5b6000612872868661258a565b935050602061288386828701612843565b925050604084013567ffffffffffffffff8111156128a3576128a3600080fd5b61283186828701612511565b61241a81612570565b602081016104a382846128af565b602080825281016106b7818461262e565b6000806000606084860312156128ef576128ef600080fd5b833567ffffffffffffffff81111561290957612909600080fd5b61291586828701612511565b9350506020612926868287016123e2565b92505060406128318682870161258a565b6001600160801b03811661241a565b60a08101612954828861242e565b6129616020830187612416565b61296e6040830186612937565b61297b606083018561242e565b612988608083018461242e565b9695505050505050565b634e487b7160e01b600052601160045260246000fd5b8181028082158382048514176129c0576129c0612992565b5092915050565b634e487b7160e01b600052601260045260246000fd5b6000826129ec576129ec6129c7565b500490565b601281526000602082017f41707065616c2073746172746564207965740000000000000000000000000000815291505b5060200190565b602080825281016104a3816129f1565b601f81526000602082017f4f6e6c792072656665726565732063616e2073746172742061707065616c730081529150612a21565b602080825281016104a381612a38565b602481526000602082017f4475706c696361746520726566657265657320617265206e6f74207065726d6981527f7474656400000000000000000000000000000000000000000000000000000000602082015291505b5060400190565b602080825281016104a381612a7c565b634e487b7160e01b600052602260045260246000fd5b600281046001821680612b1357607f821691505b602082108103612b2557612b25612ae9565b50919050565b60006104a3612b378381565b90565b612b4383612b2b565b81546008840282811b60001990911b908116901990911617825550505050565b60006112a6818484612b3a565b81811015612b8b57612b83600082612b63565b600101612b70565b5050565b601f8211156112a6576000818152602090206020601f85010481016020851015612bb65750805b612bc86020601f860104830182612b70565b5050505050565b815167ffffffffffffffff811115612be957612be9612442565b612bf38254612aff565b612bfe828285612b8f565b6020601f831160018114612c325760008415612c1a5750858201515b600019600886021c1981166002860217865550611134565b600085815260208120601f198616915b82811015612c625788850151825560209485019460019092019101612c42565b86831015612c7e5784890151600019601f89166008021c191682555b600160028802018855505050505050505050565b60408101612ca0828561242e565b6106b760208301846128af565b80516104a38161283b565b600060208284031215612ccd57612ccd600080fd5b600061240e8484612cad565b60ff81166123d7565b80516104a381612cd9565b600060208284031215612d0257612d02600080fd5b600061240e8484612ce2565b80516104a3816123d5565b600060208284031215612d2e57612d2e600080fd5b600061240e8484612d0e565b602381526000602082017f70726f6365737341707065616c3a204475706c6963617465207369676e61747581527f726573000000000000000000000000000000000000000000000000000000000060208201529150612ad2565b602080825281016104a381612d3a565b601281526000602082017f4465616c206973206e6f7420616374697665000000000000000000000000000081529150612a21565b602080825281016104a381612da4565b601481526000602082017f41707065616c206973206e6f742061637469766500000000000000000000000081529150612a21565b602080825281016104a381612de8565b602181526000602082017f4f6e6c792072656665726565732063616e2070726f636573732061707065616c81527f730000000000000000000000000000000000000000000000000000000000000060208201529150612ad2565b602080825281016104a381612e2c565b602681526000602082017f546869732061707065616c2063616e27742062652070726f636573736564206181527f6e796d6f7265000000000000000000000000000000000000000000000000000060208201529150612ad2565b602080825281016104a381612e96565b601c81526000602082017f5468697320726f756e64207761732070726f636573736564207965740000000081529150612a21565b602080825281016104a381612f00565b6001600160801b031660007fffffffffffffffffffffffffffffffff000000000000000000000000000000018201612f7e57612f7e612992565b5060010190565b634e487b7160e01b600052603260045260246000fd5b601981526000602082017f5369676e617475726520646f65736e2774206d6174636865730000000000000081529150612a21565b602080825281016104a381612f9b565b60006000198203612f7e57612f7e612992565b603581526000602082017f41707065616c207761736e277420736c61736865642c206e6f7420746865206c81527f6561646572206f72206e6f20636f6e73656e737573000000000000000000000060208201529150612ad2565b602080825281016104a381612ff2565b80516104a381612581565b60006020828403121561307c5761307c600080fd5b600061240e848461305c565b6040810161309682856128af565b6106b7602083018461242e565b808201808211156104a3576104a3612992565b60006130c2828461242e565b50602001919050565b818103818111156104a3576104a3612992565b63ffffffff81166123d7565b80516104a3816130de565b60006020828403121561310a5761310a600080fd5b600061240e84846130ea565b63ffffffff9182169190811690828202908116908181146129c0576129c0612992565b6000613143825190565b61315181856020860161260a565b9290920192915050565b60006131678286613139565b91506131738285613139565b915061317f8284613139565b95945050505050565b602181526000602082017f50726f76696465642061646472657373206973206e6f7420612072656665726581527f650000000000000000000000000000000000000000000000000000000000000060208201529150612ad2565b602080825281016104a381613188565b602181526000602082017f43616e277420637265617465206d6f72652061707065616c73206f6e2064656181527f6c0000000000000000000000000000000000000000000000000000000000000060208201529150612ad2565b602080825281016104a3816131f2565b60208082527f4465616c20656e6465642c2063616e2774206372656174652061707065616c7391019081526000612a21565b602080825281016104a38161325c565b602b81526000602082017f4f6e6c7920617574686f72697a6564206164647265737365732063616e20637281527f656174652061707065616c00000000000000000000000000000000000000000060208201529150612ad2565b602080825281016104a38161329e565b60208082527f5468657265277320612070656e64696e672061707065616c207265717565737491019081526000612a21565b602080825281016104a381613308565b602381526000602082017f41707065616c206578697374732079657420666f722070726f7669646564206881527f617368000000000000000000000000000000000000000000000000000000000060208201529150612ad2565b602080825281016104a38161334a565b603581526000602082017f4d757374206861766520656e6f7567682062616c616e636520696e207661756c81527f7420746f2063726561746520616e2061707065616c000000000000000000000060208201529150612ad2565b602080825281016104a3816133b4565b60ff16600060fe198201612f7e57612f7e612992565b60608101613442828661242e565b61344f60208301856128af565b61240e604083018461242e565b602681526000602082017f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206181527f646472657373000000000000000000000000000000000000000000000000000060208201529150612ad2565b602080825281016104a38161345c565b60006106b78284613139565b60208082527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657291019081526000612a21565b602080825281016104a3816134d2565b601281526000602082017f696e646578206f7574206f6620626f756e64000000000000000000000000000081529150612a21565b602080825281016104a381613514565b634e487b7160e01b600052603160045260246000fd5b7f19457468657265756d205369676e6564204d6573736167653a0a0000000000008152601a0160006135a08285613139565b915061240e8284613139565b601f81526000602082017f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0081529150612a21565b602080825281016104a3816135ac565b634e487b7160e01b600052602160045260246000fd5b601881526000602082017f45434453413a20696e76616c6964207369676e6174757265000000000000000081529150612a21565b602080825281016104a381613606565b601f81526000602082017f45434453413a20696e76616c6964207369676e6174757265206c656e6774680081529150612a21565b602080825281016104a38161364a565b602281526000602082017f45434453413a20696e76616c6964207369676e6174757265202773272076616c81527f756500000000000000000000000000000000000000000000000000000000000060208201529150612ad2565b602080825281016104a38161368e565b60808101613706828761242e565b61371360208301866125d2565b613720604083018561242e565b61317f606083018461242e56fea26469706673582212203097d12b5ea32605fc23b1a367a3a68eb4dfcbf22b171f4dbadc4a872cbd1d5b64736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101ae5760003560e01c806388ca9d2f116100ee578063a008d89311610097578063acff868711610071578063acff8687146103ee578063f0b070ca1461044a578063f2fde38b1461045d578063f3c4e5f21461047057600080fd5b8063a008d8931461038f578063a44afce2146103bb578063ace71f63146103db57600080fd5b80638f1327c0116100c85780638f1327c01461033857806392bf42891461034b5780639414b9021461036f57600080fd5b806388ca9d2f146102f457806388f8724d146103075780638da5cb5b1461032757600080fd5b806339ab480a1161015b5780636aa921cd116101355780636aa921cd146102a6578063715018a6146102b957806383a0dbfe146102c157806386478a0a146102e157600080fd5b806339ab480a146102425780633d3030391461025557806364a60b471461028557600080fd5b8063212180811161018c57806321218081146102075780633889107f1461021c57806338b1f7521461022f57600080fd5b80630e1f06fb146101b357806314d967d1146101ea5780631fa879e8146101ff575b600080fd5b6101d46101c13660046123ed565b6000908152600960205260409020541590565b6040516101e19190612420565b60405180910390f35b6101f2610483565b6040516101e19190612434565b6101f26104a9565b61021a6102153660046123ed565b6104b9565b005b61021a61022a366004612535565b61058d565b6101d461023d366004612595565b61062a565b6101f26102503660046123ed565b6106be565b6102786102633660046123ed565b60086020526000908152604090205460ff1681565b6040516101e191906125db565b6102986102933660046125e9565b6107ba565b6040516101e1929190612660565b61021a6102b43660046127b5565b610863565b61021a61113c565b6101f26102cf3660046123ed565b60096020526000908152604090205481565b61021a6102ef3660046125e9565b611150565b61021a61030236600461284e565b61117a565b61031a6103153660046123ed565b6112ab565b6040516101e191906128b8565b6000546001600160a01b031661031a565b6101f26103463660046123ed565b611366565b6101d46103593660046123ed565b6000908152600a60205260409020546063111590565b61038261037d3660046123ed565b6115cb565b6040516101e191906128c6565b6101d461039d3660046125e9565b6001600160a01b031660009081526005602052604090205460ff1690565b6101f26103c93660046123ed565b600a6020526000908152604090205481565b6101d46103e93660046128d7565b61162d565b6104396103fc3660046123ed565b60076020526000908152604090208054600182015460038301546004840154600590940154929360ff909216926001600160801b03909116919085565b6040516101e1959493929190612946565b61021a6104583660046123ed565b6116a5565b61021a61046b3660046125e9565b611d05565b61031a61047e3660046123ed565b611d3c565b60065460009081906002906104999060646129a8565b6104a391906129dd565b92915050565b60006104b4600b5490565b905090565b600081815260076020526040902060050154156104f15760405162461bcd60e51b81526004016104e890612a28565b60405180910390fd5b3360009081526005602052604090205460ff166105205760405162461bcd60e51b81526004016104e890612a6c565b60008181526007602090815260408083204260058201558054845260098352818420849055548352600a90915290819020829055517f5f2f99bd7614bf1ceaf9ef1d2e1a64cf8de13e424ae866a950717befe7b05de290610582908390612434565b60405180910390a150565b3360009081526005602052604090205460ff16156105bd5760405162461bcd60e51b81526004016104e890612ad9565b336000908152600560205260409020805460ff191660019081178255016105e48282612bcf565b5050600680546001810182556000919091527ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f0180546001600160a01b03191633179055565b6003546040517f02a8fbaf0000000000000000000000000000000000000000000000000000000081526000916001600160a01b0316906302a8fbaf906106769086908690600401612c92565b602060405180830381865afa158015610693573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106b79190612cb8565b9392505050565b600080600260009054906101000a90046001600160a01b03166001600160a01b0316632fe586116040518163ffffffff1660e01b8152600401602060405180830381865afa158015610714573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107389190612ced565b6003546040516307fa648b60e11b815260ff92909216916001600160a01b0390911690630ff4c9169061076f908790600401612434565b602060405180830381865afa15801561078c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107b09190612d19565b6106b791906129dd565b6005602052600090815260409020805460018201805460ff90921692916107e090612aff565b80601f016020809104026020016040519081016040528092919081815260200182805461080c90612aff565b80156108595780601f1061082e57610100808354040283529160200191610859565b820191906000526020600020905b81548152906001019060200180831161083c57829003601f168201915b5050505050905082565b6000838152600a60205260408120549061087c82611366565b905061088783611d66565b156108a45760405162461bcd60e51b81526004016104e890612d94565b6003546040516382afd23b60e01b81526001600160a01b03909116906382afd23b906108d4908890600401612434565b602060405180830381865afa1580156108f1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109159190612cb8565b6109315760405162461bcd60e51b81526004016104e890612dd8565b60008281526007602052604090206001015460ff166109625760405162461bcd60e51b81526004016104e890612e1c565b3360009081526005602052604090205460ff166109915760405162461bcd60e51b81526004016104e890612e86565b600260009054906101000a90046001600160a01b03166001600160a01b031663335d4d5b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156109e4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a089190612ced565b60ff16811115610a2a5760405162461bcd60e51b81526004016104e890612ef0565b600082815260076020908152604080832084845260020190915290205460ff1615610a675760405162461bcd60e51b81526004016104e890612f34565b60008281526007602090815260408083208484526002019091528120805460ff1916600117905533610a98846112ab565b6001600160a01b031603610afa57600083815260076020526040812060030180546001600160801b031691610acc83612f44565b91906101000a8154816001600160801b0302191690836001600160801b031602179055505060019050610bea565b60005b8551811015610b7e576000868281518110610b1a57610b1a612f85565b602002602001015190506000868381518110610b3857610b38612f85565b60200260200101519050610b4d818a8461162d565b610b695760405162461bcd60e51b81526004016104e890612fcf565b50508080610b7690612fdf565b915050610afd565b50610b87610483565b8451610b949060646129a8565b1115610bea57600083815260076020526040812060030180546001600160801b031691610bc083612f44565b91906101000a8154816001600160801b0302191690836001600160801b0316021790555050600190505b80610c075760405162461bcd60e51b81526004016104e89061304c565b7fa1c5ef3d5097627088df57042f85d34fffc6946dc075a6c46c90f11ba02f11b283604051610c369190612434565b60405180910390a1600260009054906101000a90046001600160a01b03166001600160a01b0316636522514f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c91573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cb59190612ced565b60008481526007602052604090206003015460ff919091166001600160801b0390911610611134576003546040517f1f77f6a80000000000000000000000000000000000000000000000000000000081526001600160a01b0390911690631f77f6a890610d26908990600401612434565b600060405180830381600087803b158015610d4057600080fd5b505af1158015610d54573d6000803e3d6000fd5b50505060008481526007602052604090819020600101805460ff191690556004805460035492516307fa648b60e11b81526001600160a01b03918216945063f33e22529390911691630ff4c91691610dae918c9101612434565b602060405180830381865afa158015610dcb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610def9190612d19565b6040518263ffffffff1660e01b8152600401610e0b9190612434565b600060405180830381600087803b158015610e2557600080fd5b505af1158015610e39573d6000803e3d6000fd5b50506004805460035460405163620d1b0560e11b81526001600160a01b03928316955063f5d82b6b945091169163c41a360a91610e78918c9101612434565b602060405180830381865afa158015610e95573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eb99190613067565b6003546040516307fa648b60e11b81526001600160a01b0390911690630ff4c91690610ee9908c90600401612434565b602060405180830381865afa158015610f06573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f2a9190612d19565b6040518363ffffffff1660e01b8152600401610f47929190613088565b600060405180830381600087803b158015610f6157600080fd5b505af1158015610f75573d6000803e3d6000fd5b50506003546040517f2a62a490000000000000000000000000000000000000000000000000000000008152600093506001600160a01b039091169150632a62a49090610fc5908a90600401612434565b602060405180830381865afa158015610fe2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110069190612d19565b600480546040517ff33e22520000000000000000000000000000000000000000000000000000000081529293506001600160a01b03169163f33e22529161104f91859101612434565b600060405180830381600087803b15801561106957600080fd5b505af115801561107d573d6000803e3d6000fd5b5050600480546040517f98c991b30000000000000000000000000000000000000000000000000000000081526001600160a01b0390911693506398c991b392506110c991859101612434565b600060405180830381600087803b1580156110e357600080fd5b505af11580156110f7573d6000803e3d6000fd5b505050507f6d23472f0f752e5a870afc2dc90ac634638d1333424ca7e389afe92815383b278760405161112a9190612434565b60405180910390a1505b505050505050565b611144611eb9565b61114e6000611ee3565b565b611158611eb9565b600380546001600160a01b0319166001600160a01b0392909216919091179055565b611182611eb9565b8115611245576001600160a01b03831660009081526005602052604090205460ff16156111c15760405162461bcd60e51b81526004016104e890612ad9565b6001600160a01b0383166000908152600560205260409020805460ff19168315151781556001016111f28282612bcf565b50600680546001810182556000919091527ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f0180546001600160a01b0385166001600160a01b0319909116179055505050565b60005b6006548110156112a457836001600160a01b03166006828154811061126f5761126f612f85565b6000918252602090912001546001600160a01b0316036112925761129281611f33565b8061129c81612fdf565b915050611248565b505b505050565b6000806112b783611366565b6000848152600760205260408120600501549192509082906112da9086906130a3565b6112e491906130a3565b6040516020016112f491906130b6565b60408051601f19818403018152919052805160209091012060065490915060009061131f81846129dd565b61132991906129a8565b61133390836130cb565b90506006818154811061134857611348612f85565b6000918252602090912001546001600160a01b031695945050505050565b600080600260009054906101000a90046001600160a01b03166001600160a01b031663335d4d5b6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156113bc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113e09190612ced565b60ff16600260009054906101000a90046001600160a01b03166001600160a01b031663d1b04e9e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611436573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061145a91906130f5565b6114649190613116565b60008481526007602052604081206005015463ffffffff9290921692509061148d9083906130a3565b90504281106115c15760006114a242836130cb565b90506000600260009054906101000a90046001600160a01b03166001600160a01b031663d1b04e9e6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156114f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061151d91906130f5565b61152d9063ffffffff16836129dd565b9050600081600260009054906101000a90046001600160a01b03166001600160a01b031663335d4d5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611585573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115a99190612ced565b60ff166115b691906130cb565b979650505050505050565b5060639392505050565b6000818152600760205260408120546060916115e684611366565b90506115f182612027565b6115fa85612027565b61160383612027565b6040516020016116159392919061315b565b60405160208183030381529060405292505050919050565b6001600160a01b03811660009081526005602052604081205460ff166116655760405162461bcd60e51b81526004016104e8906131e2565b6000611670846115cb565b9050600061167d826120c8565b9050600061168b8288612103565b6001600160a01b0386811691161493505050509392505050565b6116ad61211f565b600260009054906101000a90046001600160a01b03166001600160a01b031663e13f8e6c6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611700573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117249190612ced565b60008281526008602052604090205460ff9182169116106117575760405162461bcd60e51b81526004016104e89061324c565b6003546040516382afd23b60e01b81526001600160a01b03909116906382afd23b90611787908490600401612434565b602060405180830381865afa1580156117a4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117c89190612cb8565b6117e45760405162461bcd60e51b81526004016104e890612dd8565b6003546040517f688f216e0000000000000000000000000000000000000000000000000000000081526001600160a01b039091169063688f216e9061182d908490600401612434565b602060405180830381865afa15801561184a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061186e9190612cb8565b61188a5760405162461bcd60e51b81526004016104e89061328e565b6003546040517f5a5d096c0000000000000000000000000000000000000000000000000000000081526001600160a01b0390911690635a5d096c906118d59084903390600401612c92565b602060405180830381865afa1580156118f2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119169190612cb8565b6119325760405162461bcd60e51b81526004016104e8906132f8565b6000818152600960205260409020541561195e5760405162461bcd60e51b81526004016104e89061333a565b6000818152600a6020526040902054158061199257506000818152600a602052604090205460639061198f90611366565b10155b6119ae5760405162461bcd60e51b81526004016104e8906133a4565b6119b7816106be565b600480546040517ff8b2cb4f0000000000000000000000000000000000000000000000000000000081526001600160a01b039091169163f8b2cb4f916119ff913391016128b8565b602060405180830381865afa158015611a1c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a409190612d19565b1015611a5e5760405162461bcd60e51b81526004016104e89061340e565b6004546001600160a01b03166326ffee0833611a79846106be565b6040518363ffffffff1660e01b8152600401611a96929190613088565b600060405180830381600087803b158015611ab057600080fd5b505af1158015611ac4573d6000803e3d6000fd5b505050506000611ad3826106be565b6000838152600860205260408120805492935060ff9092169190611af68361341e565b91906101000a81548160ff021916908360ff160217905550506000811115611bf957600654600090611b2890836129dd565b905060005b600654811015611bf657600454600680546001600160a01b039092169163f5d82b6b919084908110611b6157611b61612f85565b6000918252602090912001546040517fffffffff0000000000000000000000000000000000000000000000000000000060e084901b168152611bb1916001600160a01b0316908690600401613088565b600060405180830381600087803b158015611bcb57600080fd5b505af1158015611bdf573d6000803e3d6000fd5b505050508080611bee90612fdf565b915050611b2d565b50505b611c07600b80546001019055565b6000611c12600b5490565b60008481526009602090815260408083208490558383526007909152908190208581556001808201805460ff1916909117905542600491820155600354915163620d1b0560e11b81529293507ff56725243f2f0a402c5adb1e89c210b1486962a45b63f1768a2fdccae95e6f359284926001600160a01b03169163c41a360a91611c9e91899101612434565b602060405180830381865afa158015611cbb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cdf9190613067565b85604051611cef93929190613434565b60405180910390a15050611d0260018055565b50565b611d0d611eb9565b6001600160a01b038116611d335760405162461bcd60e51b81526004016104e8906134b6565b611d0281611ee3565b60068181548110611d4c57600080fd5b6000918252602090912001546001600160a01b0316905081565b60008151600003611d7957506000919050565b60005b60018351611d8a91906130cb565b811015611eb0576000611d9e8260016130a3565b90505b8351811015611e9d576002848281518110611dbe57611dbe612f85565b6020026020010151604051611dd391906134c6565b602060405180830381855afa158015611df0573d6000803e3d6000fd5b5050506040513d601f19601f82011682018060405250810190611e139190612d19565b6002858481518110611e2757611e27612f85565b6020026020010151604051611e3c91906134c6565b602060405180830381855afa158015611e59573d6000803e3d6000fd5b5050506040513d601f19601f82011682018060405250810190611e7c9190612d19565b03611e8b575060019392505050565b80611e9581612fdf565b915050611da1565b5080611ea881612fdf565b915050611d7c565b50600092915050565b6000546001600160a01b0316331461114e5760405162461bcd60e51b81526004016104e890613504565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6006548110611f545760405162461bcd60e51b81526004016104e890613548565b805b600654611f65906001906130cb565b811015611ff0576006611f798260016130a3565b81548110611f8957611f89612f85565b600091825260209091200154600680546001600160a01b039092169183908110611fb557611fb5612f85565b600091825260209091200180546001600160a01b0319166001600160a01b039290921691909117905580611fe881612fdf565b915050611f56565b50600680548061200257612002613558565b600082815260209020810160001990810180546001600160a01b031916905501905550565b6060600061203483612148565b600101905060008167ffffffffffffffff81111561205457612054612442565b6040519080825280601f01601f19166020018201604052801561207e576020820181803683370190505b5090508181016020015b600019017f3031323334353637383961626364656600000000000000000000000000000000600a86061a8153600a8504945084612088575b509392505050565b60006120d48251612027565b826040516020016120e692919061356e565b604051602081830303815290604052805190602001209050919050565b6000806000612112858561222a565b915091506120c08161226f565b6002600154036121415760405162461bcd60e51b81526004016104e8906135e0565b6002600155565b6000807a184f03e93ff9f4daa797ed6e38ed64bf6a1f0100000000000000008310612191577a184f03e93ff9f4daa797ed6e38ed64bf6a1f010000000000000000830492506040015b6d04ee2d6d415b85acef810000000083106121bd576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc1000083106121db57662386f26fc10000830492506010015b6305f5e10083106121f3576305f5e100830492506008015b612710831061220757612710830492506004015b60648310612219576064830492506002015b600a83106104a35760010192915050565b60008082516041036122605760208301516040840151606085015160001a6122548782858561231e565b94509450505050612268565b506000905060025b9250929050565b6000816004811115612283576122836135f0565b0361228b5750565b600181600481111561229f5761229f6135f0565b036122bc5760405162461bcd60e51b81526004016104e89061363a565b60028160048111156122d0576122d06135f0565b036122ed5760405162461bcd60e51b81526004016104e89061367e565b6003816004811115612301576123016135f0565b03611d025760405162461bcd60e51b81526004016104e8906136e8565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a083111561235557506000905060036123cc565b60006001878787876040516000815260200160405260405161237a94939291906136f8565b6020604051602081039080840390855afa15801561239c573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b0381166123c5576000600192509250506123cc565b9150600090505b94509492505050565b805b8114611d0257600080fd5b80356104a3816123d5565b60006020828403121561240257612402600080fd5b600061240e84846123e2565b949350505050565b8015155b82525050565b602081016104a38284612416565b8061241a565b602081016104a3828461242e565b634e487b7160e01b600052604160045260246000fd5b601f19601f830116810181811067ffffffffffffffff8211171561247e5761247e612442565b6040525050565b600061249060405190565b905061249c8282612458565b919050565b600067ffffffffffffffff8211156124bb576124bb612442565b601f19601f83011660200192915050565b82818337506000910152565b60006124eb6124e6846124a1565b612485565b90508281526020810184848401111561250657612506600080fd5b6120c08482856124cc565b600082601f83011261252557612525600080fd5b813561240e8482602086016124d8565b60006020828403121561254a5761254a600080fd5b813567ffffffffffffffff81111561256457612564600080fd5b61240e84828501612511565b60006001600160a01b0382166104a3565b6123d781612570565b80356104a381612581565b600080604083850312156125ab576125ab600080fd5b60006125b785856123e2565b92505060206125c88582860161258a565b9150509250929050565b60ff811661241a565b602081016104a382846125d2565b6000602082840312156125fe576125fe600080fd5b600061240e848461258a565b60005b8381101561262557818101518382015260200161260d565b50506000910152565b6000612638825190565b80845260208401935061264f81856020860161260a565b601f01601f19169290920192915050565b6040810161266e8285612416565b818103602083015261240e818461262e565b600067ffffffffffffffff82111561269a5761269a612442565b5060209081020190565b60006126b26124e684612680565b838152905060208082019084028301858111156126d1576126d1600080fd5b835b818110156126f557806126e6888261258a565b845250602092830192016126d3565b5050509392505050565b600082601f83011261271357612713600080fd5b813561240e8482602086016126a4565b60006127316124e684612680565b8381529050602080820190840283018581111561275057612750600080fd5b835b818110156126f557803567ffffffffffffffff81111561277457612774600080fd5b8086016127818982612511565b8552505060209283019201612752565b600082601f8301126127a5576127a5600080fd5b813561240e848260208601612723565b6000806000606084860312156127cd576127cd600080fd5b60006127d986866123e2565b935050602084013567ffffffffffffffff8111156127f9576127f9600080fd5b612805868287016126ff565b925050604084013567ffffffffffffffff81111561282557612825600080fd5b61283186828701612791565b9150509250925092565b8015156123d7565b80356104a38161283b565b60008060006060848603121561286657612866600080fd5b6000612872868661258a565b935050602061288386828701612843565b925050604084013567ffffffffffffffff8111156128a3576128a3600080fd5b61283186828701612511565b61241a81612570565b602081016104a382846128af565b602080825281016106b7818461262e565b6000806000606084860312156128ef576128ef600080fd5b833567ffffffffffffffff81111561290957612909600080fd5b61291586828701612511565b9350506020612926868287016123e2565b92505060406128318682870161258a565b6001600160801b03811661241a565b60a08101612954828861242e565b6129616020830187612416565b61296e6040830186612937565b61297b606083018561242e565b612988608083018461242e565b9695505050505050565b634e487b7160e01b600052601160045260246000fd5b8181028082158382048514176129c0576129c0612992565b5092915050565b634e487b7160e01b600052601260045260246000fd5b6000826129ec576129ec6129c7565b500490565b601281526000602082017f41707065616c2073746172746564207965740000000000000000000000000000815291505b5060200190565b602080825281016104a3816129f1565b601f81526000602082017f4f6e6c792072656665726565732063616e2073746172742061707065616c730081529150612a21565b602080825281016104a381612a38565b602481526000602082017f4475706c696361746520726566657265657320617265206e6f74207065726d6981527f7474656400000000000000000000000000000000000000000000000000000000602082015291505b5060400190565b602080825281016104a381612a7c565b634e487b7160e01b600052602260045260246000fd5b600281046001821680612b1357607f821691505b602082108103612b2557612b25612ae9565b50919050565b60006104a3612b378381565b90565b612b4383612b2b565b81546008840282811b60001990911b908116901990911617825550505050565b60006112a6818484612b3a565b81811015612b8b57612b83600082612b63565b600101612b70565b5050565b601f8211156112a6576000818152602090206020601f85010481016020851015612bb65750805b612bc86020601f860104830182612b70565b5050505050565b815167ffffffffffffffff811115612be957612be9612442565b612bf38254612aff565b612bfe828285612b8f565b6020601f831160018114612c325760008415612c1a5750858201515b600019600886021c1981166002860217865550611134565b600085815260208120601f198616915b82811015612c625788850151825560209485019460019092019101612c42565b86831015612c7e5784890151600019601f89166008021c191682555b600160028802018855505050505050505050565b60408101612ca0828561242e565b6106b760208301846128af565b80516104a38161283b565b600060208284031215612ccd57612ccd600080fd5b600061240e8484612cad565b60ff81166123d7565b80516104a381612cd9565b600060208284031215612d0257612d02600080fd5b600061240e8484612ce2565b80516104a3816123d5565b600060208284031215612d2e57612d2e600080fd5b600061240e8484612d0e565b602381526000602082017f70726f6365737341707065616c3a204475706c6963617465207369676e61747581527f726573000000000000000000000000000000000000000000000000000000000060208201529150612ad2565b602080825281016104a381612d3a565b601281526000602082017f4465616c206973206e6f7420616374697665000000000000000000000000000081529150612a21565b602080825281016104a381612da4565b601481526000602082017f41707065616c206973206e6f742061637469766500000000000000000000000081529150612a21565b602080825281016104a381612de8565b602181526000602082017f4f6e6c792072656665726565732063616e2070726f636573732061707065616c81527f730000000000000000000000000000000000000000000000000000000000000060208201529150612ad2565b602080825281016104a381612e2c565b602681526000602082017f546869732061707065616c2063616e27742062652070726f636573736564206181527f6e796d6f7265000000000000000000000000000000000000000000000000000060208201529150612ad2565b602080825281016104a381612e96565b601c81526000602082017f5468697320726f756e64207761732070726f636573736564207965740000000081529150612a21565b602080825281016104a381612f00565b6001600160801b031660007fffffffffffffffffffffffffffffffff000000000000000000000000000000018201612f7e57612f7e612992565b5060010190565b634e487b7160e01b600052603260045260246000fd5b601981526000602082017f5369676e617475726520646f65736e2774206d6174636865730000000000000081529150612a21565b602080825281016104a381612f9b565b60006000198203612f7e57612f7e612992565b603581526000602082017f41707065616c207761736e277420736c61736865642c206e6f7420746865206c81527f6561646572206f72206e6f20636f6e73656e737573000000000000000000000060208201529150612ad2565b602080825281016104a381612ff2565b80516104a381612581565b60006020828403121561307c5761307c600080fd5b600061240e848461305c565b6040810161309682856128af565b6106b7602083018461242e565b808201808211156104a3576104a3612992565b60006130c2828461242e565b50602001919050565b818103818111156104a3576104a3612992565b63ffffffff81166123d7565b80516104a3816130de565b60006020828403121561310a5761310a600080fd5b600061240e84846130ea565b63ffffffff9182169190811690828202908116908181146129c0576129c0612992565b6000613143825190565b61315181856020860161260a565b9290920192915050565b60006131678286613139565b91506131738285613139565b915061317f8284613139565b95945050505050565b602181526000602082017f50726f76696465642061646472657373206973206e6f7420612072656665726581527f650000000000000000000000000000000000000000000000000000000000000060208201529150612ad2565b602080825281016104a381613188565b602181526000602082017f43616e277420637265617465206d6f72652061707065616c73206f6e2064656181527f6c0000000000000000000000000000000000000000000000000000000000000060208201529150612ad2565b602080825281016104a3816131f2565b60208082527f4465616c20656e6465642c2063616e2774206372656174652061707065616c7391019081526000612a21565b602080825281016104a38161325c565b602b81526000602082017f4f6e6c7920617574686f72697a6564206164647265737365732063616e20637281527f656174652061707065616c00000000000000000000000000000000000000000060208201529150612ad2565b602080825281016104a38161329e565b60208082527f5468657265277320612070656e64696e672061707065616c207265717565737491019081526000612a21565b602080825281016104a381613308565b602381526000602082017f41707065616c206578697374732079657420666f722070726f7669646564206881527f617368000000000000000000000000000000000000000000000000000000000060208201529150612ad2565b602080825281016104a38161334a565b603581526000602082017f4d757374206861766520656e6f7567682062616c616e636520696e207661756c81527f7420746f2063726561746520616e2061707065616c000000000000000000000060208201529150612ad2565b602080825281016104a3816133b4565b60ff16600060fe198201612f7e57612f7e612992565b60608101613442828661242e565b61344f60208301856128af565b61240e604083018461242e565b602681526000602082017f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206181527f646472657373000000000000000000000000000000000000000000000000000060208201529150612ad2565b602080825281016104a38161345c565b60006106b78284613139565b60208082527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657291019081526000612a21565b602080825281016104a3816134d2565b601281526000602082017f696e646578206f7574206f6620626f756e64000000000000000000000000000081529150612a21565b602080825281016104a381613514565b634e487b7160e01b600052603160045260246000fd5b7f19457468657265756d205369676e6564204d6573736167653a0a0000000000008152601a0160006135a08285613139565b915061240e8284613139565b601f81526000602082017f5265656e7472616e637947756172643a207265656e7472616e742063616c6c0081529150612a21565b602080825281016104a3816135ac565b634e487b7160e01b600052602160045260246000fd5b601881526000602082017f45434453413a20696e76616c6964207369676e6174757265000000000000000081529150612a21565b602080825281016104a381613606565b601f81526000602082017f45434453413a20696e76616c6964207369676e6174757265206c656e6774680081529150612a21565b602080825281016104a38161364a565b602281526000602082017f45434453413a20696e76616c6964207369676e6174757265202773272076616c81527f756500000000000000000000000000000000000000000000000000000000000060208201529150612ad2565b602080825281016104a38161368e565b60808101613706828761242e565b61371360208301866125d2565b613720604083018561242e565b61317f606083018461242e56fea26469706673582212203097d12b5ea32605fc23b1a367a3a68eb4dfcbf22b171f4dbadc4a872cbd1d5b64736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "title": "Appeals",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 817,
        "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 933,
        "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
        "label": "_status",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 8587,
        "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
        "label": "settings",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(Settings)12564"
      },
      {
        "astId": 8590,
        "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
        "label": "dealsStore",
        "offset": 0,
        "slot": "3",
        "type": "t_contract(Deals)10834"
      },
      {
        "astId": 8593,
        "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
        "label": "vaultStore",
        "offset": 0,
        "slot": "4",
        "type": "t_contract(Vault)13051"
      },
      {
        "astId": 8598,
        "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
        "label": "referees",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_struct(Referee)8569_storage)"
      },
      {
        "astId": 8601,
        "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
        "label": "active_referees",
        "offset": 0,
        "slot": "6",
        "type": "t_array(t_address)dyn_storage"
      },
      {
        "astId": 8606,
        "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
        "label": "appeals",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_uint256,t_struct(Appeal)8584_storage)"
      },
      {
        "astId": 8610,
        "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
        "label": "tot_appeals",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_uint256,t_uint8)"
      },
      {
        "astId": 8614,
        "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
        "label": "pending_appeals",
        "offset": 0,
        "slot": "9",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 8618,
        "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
        "label": "active_appeals",
        "offset": 0,
        "slot": "10",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 8641,
        "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
        "label": "appealCounter",
        "offset": 0,
        "slot": "11",
        "type": "t_struct(Counter)1506_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(Deals)10834": {
        "encoding": "inplace",
        "label": "contract Deals",
        "numberOfBytes": "20"
      },
      "t_contract(Settings)12564": {
        "encoding": "inplace",
        "label": "contract Settings",
        "numberOfBytes": "20"
      },
      "t_contract(Vault)13051": {
        "encoding": "inplace",
        "label": "contract Vault",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_struct(Referee)8569_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct Appeals.Referee)",
        "numberOfBytes": "32",
        "value": "t_struct(Referee)8569_storage"
      },
      "t_mapping(t_uint256,t_bool)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_uint256,t_struct(Appeal)8584_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Appeals.Appeal)",
        "numberOfBytes": "32",
        "value": "t_struct(Appeal)8584_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_uint8)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint8)",
        "numberOfBytes": "32",
        "value": "t_uint8"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(Appeal)8584_storage": {
        "encoding": "inplace",
        "label": "struct Appeals.Appeal",
        "members": [
          {
            "astId": 8571,
            "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
            "label": "deal_index",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 8573,
            "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
            "label": "active",
            "offset": 0,
            "slot": "1",
            "type": "t_bool"
          },
          {
            "astId": 8577,
            "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
            "label": "processed",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_uint256,t_bool)"
          },
          {
            "astId": 8579,
            "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
            "label": "slashes",
            "offset": 0,
            "slot": "3",
            "type": "t_uint128"
          },
          {
            "astId": 8581,
            "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
            "label": "request_timestamp",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 8583,
            "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
            "label": "origin_timestamp",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "192"
      },
      "t_struct(Counter)1506_storage": {
        "encoding": "inplace",
        "label": "struct Counters.Counter",
        "members": [
          {
            "astId": 1505,
            "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
            "label": "_value",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Referee)8569_storage": {
        "encoding": "inplace",
        "label": "struct Appeals.Referee",
        "members": [
          {
            "astId": 8566,
            "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
            "label": "active",
            "offset": 0,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 8568,
            "contract": "contracts/retrieve/appeals/Appeals.sol:Appeals",
            "label": "endpoint",
            "offset": 0,
            "slot": "1",
            "type": "t_string_storage"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}